In archive libDrivers.a:

adc.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000438  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000007b4  00000000  00000000  0000046c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.ADC_init 0000001e  00000000  00000000  00000c20  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.ADC_readChannel 0000006e  00000000  00000000  00000c3e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.ADC_init:

00000000 <ADC_init>:
 * Description :
 * Function responsible for initialize the ADC driver.
 */

void ADC_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	 * REFS1:0 = 11 to choose to connect Internal 2.56V Voltage Reference with external capacitor at AREF pin

	 * ADLAR   = 0 right adjusted
	 * MUX4:0  = 00000 to choose channel 0 as initialization
	 */
	ADMUX = (1<<REFS0) | (1<<REFS1);
   8:	e7 e2       	ldi	r30, 0x27	; 39
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 ec       	ldi	r24, 0xC0	; 192
   e:	80 83       	st	Z, r24
	 * ADEN    = 1 Enable ADC
	 * ADIE    = 0 Disable ADC Interrupt
	 * ADATE   = 0 Disable Auto Trigger
	 * ADPS2:0 = 111 to choose ADC_Clock = F_CPU/128 = 16Mhz/8 = 125Khz --> ADC must operate in range 50-200Khz
	 */
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
  10:	e6 e2       	ldi	r30, 0x26	; 38
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	87 e8       	ldi	r24, 0x87	; 135
  16:	80 83       	st	Z, r24
}
  18:	cf 91       	pop	r28
  1a:	df 91       	pop	r29
  1c:	08 95       	ret

Disassembly of section .text.ADC_readChannel:

00000000 <ADC_readChannel>:
 * Description :
 * Function responsible for initialize the ADC driver.
 */

void ADC_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
	 * REFS1:0 = 11 to choose to connect Internal 2.56V Voltage Reference with external capacitor at AREF pin

	 * ADLAR   = 0 right adjusted
	 * MUX4:0  = 00000 to choose channel 0 as initialization
	 */
	ADMUX = (1<<REFS0) | (1<<REFS1);
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	89 81       	ldd	r24, Y+1	; 0x01
   e:	87 70       	andi	r24, 0x07	; 7
	 * ADEN    = 1 Enable ADC
	 * ADIE    = 0 Disable ADC Interrupt
	 * ADATE   = 0 Disable Auto Trigger
	 * ADPS2:0 = 111 to choose ADC_Clock = F_CPU/128 = 16Mhz/8 = 125Khz --> ADC must operate in range 50-200Khz
	 */
	ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
  10:	89 83       	std	Y+1, r24	; 0x01
  12:	a7 e2       	ldi	r26, 0x27	; 39
  14:	b0 e0       	ldi	r27, 0x00	; 0
  16:	e7 e2       	ldi	r30, 0x27	; 39
}
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	80 81       	ld	r24, Z
  1c:	80 7e       	andi	r24, 0xE0	; 224
  1e:	8c 93       	st	X, r24
  20:	a7 e2       	ldi	r26, 0x27	; 39
  22:	b0 e0       	ldi	r27, 0x00	; 0
  24:	e7 e2       	ldi	r30, 0x27	; 39
  26:	f0 e0       	ldi	r31, 0x00	; 0
  28:	90 81       	ld	r25, Z
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	89 2b       	or	r24, r25
  2e:	8c 93       	st	X, r24
  30:	a6 e2       	ldi	r26, 0x26	; 38
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	e6 e2       	ldi	r30, 0x26	; 38
  36:	f0 e0       	ldi	r31, 0x00	; 0
  38:	80 81       	ld	r24, Z
  3a:	80 64       	ori	r24, 0x40	; 64
  3c:	8c 93       	st	X, r24
  3e:	e6 e2       	ldi	r30, 0x26	; 38
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	80 81       	ld	r24, Z
  44:	88 2f       	mov	r24, r24
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	80 71       	andi	r24, 0x10	; 16
  4a:	90 70       	andi	r25, 0x00	; 0
  4c:	00 97       	sbiw	r24, 0x00	; 0
  4e:	01 f0       	breq	.+0      	; 0x50 <ADC_readChannel+0x50>
  50:	a6 e2       	ldi	r26, 0x26	; 38
  52:	b0 e0       	ldi	r27, 0x00	; 0
  54:	e6 e2       	ldi	r30, 0x26	; 38
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	80 81       	ld	r24, Z
  5a:	80 61       	ori	r24, 0x10	; 16
  5c:	8c 93       	st	X, r24
  5e:	e4 e2       	ldi	r30, 0x24	; 36
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	80 81       	ld	r24, Z
  64:	91 81       	ldd	r25, Z+1	; 0x01
  66:	0f 90       	pop	r0
  68:	cf 91       	pop	r28
  6a:	df 91       	pop	r29
  6c:	08 95       	ret

external_interrupts.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000063c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000009ed  00000000  00000000  00000670  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.g_callBackPtr_INT0 00000002  00000000  00000000  0000105d  2**0
                  ALLOC
  6 .bss.g_callBackPtr_INT1 00000002  00000000  00000000  0000105d  2**0
                  ALLOC
  7 .bss.g_callBackPtr_INT2 00000002  00000000  00000000  0000105d  2**0
                  ALLOC
  8 .text.__vector_1 00000066  00000000  00000000  0000105d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.__vector_2 00000066  00000000  00000000  000010c3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.__vector_3 00000066  00000000  00000000  00001129  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.external_interrupt_init 00000108  00000000  00000000  0000118f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.external_interrupt_deinit 00000098  00000000  00000000  00001297  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.external_interrupt_setCallBack 00000072  00000000  00000000  0000132f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.__vector_1:

00000000 <__vector_1>:
/*
 * ISR for INT0.
 * This ISR is called when an interrupt is triggered on INT0.
 */
ISR(INT0_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
    if(g_callBackPtr_INT0 != NULL_PTR)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_1+0x36>
    {
        /* Call the Call Back function in the application after the edge is detected */
        (*g_callBackPtr_INT0)();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
    }
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_2:

00000000 <__vector_2>:
/*
 * ISR for INT0.
 * This ISR is called when an interrupt is triggered on INT0.
 */
ISR(INT0_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
    if(g_callBackPtr_INT0 != NULL_PTR)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_2+0x36>
    {
        /* Call the Call Back function in the application after the edge is detected */
        (*g_callBackPtr_INT0)();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
    }
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_3:

00000000 <__vector_3>:
/*
 * ISR for INT0.
 * This ISR is called when an interrupt is triggered on INT0.
 */
ISR(INT0_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
    if(g_callBackPtr_INT0 != NULL_PTR)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_3+0x36>
    {
        /* Call the Call Back function in the application after the edge is detected */
        (*g_callBackPtr_INT0)();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
    }
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.external_interrupt_init:

00000000 <external_interrupt_init>:
/*
 * ISR for INT0.
 * This ISR is called when an interrupt is triggered on INT0.
 */
ISR(INT0_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <external_interrupt_init+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <external_interrupt_init+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	e9 81       	ldd	r30, Y+1	; 0x01
  12:	fa 81       	ldd	r31, Y+2	; 0x02
  14:	80 81       	ld	r24, Z
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3c 83       	std	Y+4, r19	; 0x04
  1c:	2b 83       	std	Y+3, r18	; 0x03
  1e:	8b 81       	ldd	r24, Y+3	; 0x03
  20:	9c 81       	ldd	r25, Y+4	; 0x04
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <external_interrupt_init+0x28>
  28:	2b 81       	ldd	r18, Y+3	; 0x03
    if(g_callBackPtr_INT0 != NULL_PTR)
  2a:	3c 81       	ldd	r19, Y+4	; 0x04
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	01 f4       	brne	.+0      	; 0x32 <external_interrupt_init+0x32>
  32:	00 c0       	rjmp	.+0      	; 0x34 <external_interrupt_init+0x34>
  34:	8b 81       	ldd	r24, Y+3	; 0x03
    {
        /* Call the Call Back function in the application after the edge is detected */
        (*g_callBackPtr_INT0)();
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f0       	breq	.+0      	; 0x3c <external_interrupt_init+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <external_interrupt_init+0x3e>
  3e:	a1 e3       	ldi	r26, 0x31	; 49
    }
}
  40:	b0 e0       	ldi	r27, 0x00	; 0
  42:	e1 e3       	ldi	r30, 0x31	; 49
  44:	f0 e0       	ldi	r31, 0x00	; 0
  46:	80 81       	ld	r24, Z
  48:	8b 7f       	andi	r24, 0xFB	; 251
  4a:	8c 93       	st	X, r24
  4c:	a5 e5       	ldi	r26, 0x55	; 85
  4e:	b0 e0       	ldi	r27, 0x00	; 0
  50:	e5 e5       	ldi	r30, 0x55	; 85
  52:	f0 e0       	ldi	r31, 0x00	; 0
  54:	80 81       	ld	r24, Z
  56:	98 2f       	mov	r25, r24
  58:	9c 7f       	andi	r25, 0xFC	; 252
  5a:	e9 81       	ldd	r30, Y+1	; 0x01
  5c:	fa 81       	ldd	r31, Y+2	; 0x02
  5e:	81 81       	ldd	r24, Z+1	; 0x01
  60:	89 2b       	or	r24, r25
  62:	8c 93       	st	X, r24
  64:	ab e5       	ldi	r26, 0x5B	; 91
  66:	b0 e0       	ldi	r27, 0x00	; 0
  68:	eb e5       	ldi	r30, 0x5B	; 91
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	80 81       	ld	r24, Z
  6e:	80 64       	ori	r24, 0x40	; 64
  70:	8c 93       	st	X, r24
  72:	00 c0       	rjmp	.+0      	; 0x74 <external_interrupt_init+0x74>
  74:	a1 e3       	ldi	r26, 0x31	; 49
  76:	b0 e0       	ldi	r27, 0x00	; 0
  78:	e1 e3       	ldi	r30, 0x31	; 49
  7a:	f0 e0       	ldi	r31, 0x00	; 0
  7c:	80 81       	ld	r24, Z
  7e:	87 7f       	andi	r24, 0xF7	; 247
  80:	8c 93       	st	X, r24
  82:	a5 e5       	ldi	r26, 0x55	; 85
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	e5 e5       	ldi	r30, 0x55	; 85
  88:	f0 e0       	ldi	r31, 0x00	; 0
  8a:	80 81       	ld	r24, Z
  8c:	28 2f       	mov	r18, r24
  8e:	23 7f       	andi	r18, 0xF3	; 243
  90:	e9 81       	ldd	r30, Y+1	; 0x01
  92:	fa 81       	ldd	r31, Y+2	; 0x02
  94:	81 81       	ldd	r24, Z+1	; 0x01
  96:	88 2f       	mov	r24, r24
  98:	90 e0       	ldi	r25, 0x00	; 0
  9a:	88 0f       	add	r24, r24
  9c:	99 1f       	adc	r25, r25
  9e:	88 0f       	add	r24, r24
  a0:	99 1f       	adc	r25, r25
  a2:	82 2b       	or	r24, r18
  a4:	8c 93       	st	X, r24
  a6:	ab e5       	ldi	r26, 0x5B	; 91
  a8:	b0 e0       	ldi	r27, 0x00	; 0
  aa:	eb e5       	ldi	r30, 0x5B	; 91
  ac:	f0 e0       	ldi	r31, 0x00	; 0
  ae:	80 81       	ld	r24, Z
  b0:	80 68       	ori	r24, 0x80	; 128
  b2:	8c 93       	st	X, r24
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <external_interrupt_init+0xb6>
  b6:	a7 e3       	ldi	r26, 0x37	; 55
  b8:	b0 e0       	ldi	r27, 0x00	; 0
  ba:	e7 e3       	ldi	r30, 0x37	; 55
  bc:	f0 e0       	ldi	r31, 0x00	; 0
  be:	80 81       	ld	r24, Z
  c0:	8b 7f       	andi	r24, 0xFB	; 251
  c2:	8c 93       	st	X, r24
  c4:	e9 81       	ldd	r30, Y+1	; 0x01
  c6:	fa 81       	ldd	r31, Y+2	; 0x02
  c8:	81 81       	ldd	r24, Z+1	; 0x01
  ca:	81 30       	cpi	r24, 0x01	; 1
  cc:	01 f4       	brne	.+0      	; 0xce <external_interrupt_init+0xce>
  ce:	a4 e5       	ldi	r26, 0x54	; 84
  d0:	b0 e0       	ldi	r27, 0x00	; 0
  d2:	e4 e5       	ldi	r30, 0x54	; 84
  d4:	f0 e0       	ldi	r31, 0x00	; 0
  d6:	80 81       	ld	r24, Z
  d8:	80 64       	ori	r24, 0x40	; 64
  da:	8c 93       	st	X, r24
  dc:	00 c0       	rjmp	.+0      	; 0xde <external_interrupt_init+0xde>
  de:	a4 e5       	ldi	r26, 0x54	; 84
  e0:	b0 e0       	ldi	r27, 0x00	; 0
  e2:	e4 e5       	ldi	r30, 0x54	; 84
  e4:	f0 e0       	ldi	r31, 0x00	; 0
  e6:	80 81       	ld	r24, Z
  e8:	8f 7b       	andi	r24, 0xBF	; 191
  ea:	8c 93       	st	X, r24
  ec:	ab e5       	ldi	r26, 0x5B	; 91
  ee:	b0 e0       	ldi	r27, 0x00	; 0
  f0:	eb e5       	ldi	r30, 0x5B	; 91
  f2:	f0 e0       	ldi	r31, 0x00	; 0
  f4:	80 81       	ld	r24, Z
  f6:	80 62       	ori	r24, 0x20	; 32
  f8:	8c 93       	st	X, r24
  fa:	0f 90       	pop	r0
  fc:	0f 90       	pop	r0
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
 102:	cf 91       	pop	r28
 104:	df 91       	pop	r29
 106:	08 95       	ret

Disassembly of section .text.external_interrupt_deinit:

00000000 <external_interrupt_deinit>:
/*
 * ISR for INT0.
 * This ISR is called when an interrupt is triggered on INT0.
 */
ISR(INT0_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <external_interrupt_deinit+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <external_interrupt_deinit+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
    if(g_callBackPtr_INT0 != NULL_PTR)
  2a:	01 f0       	breq	.+0      	; 0x2c <external_interrupt_deinit+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <external_interrupt_deinit+0x34>
  34:	a5 e5       	ldi	r26, 0x55	; 85
    {
        /* Call the Call Back function in the application after the edge is detected */
        (*g_callBackPtr_INT0)();
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e5 e5       	ldi	r30, 0x55	; 85
  3a:	f0 e0       	ldi	r31, 0x00	; 0
  3c:	80 81       	ld	r24, Z
  3e:	8c 7f       	andi	r24, 0xFC	; 252
    }
}
  40:	8c 93       	st	X, r24
  42:	ab e5       	ldi	r26, 0x5B	; 91
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	eb e5       	ldi	r30, 0x5B	; 91
  48:	f0 e0       	ldi	r31, 0x00	; 0
  4a:	80 81       	ld	r24, Z
  4c:	8f 7b       	andi	r24, 0xBF	; 191
  4e:	8c 93       	st	X, r24
  50:	00 c0       	rjmp	.+0      	; 0x52 <external_interrupt_deinit+0x52>
  52:	a5 e5       	ldi	r26, 0x55	; 85
  54:	b0 e0       	ldi	r27, 0x00	; 0
  56:	e5 e5       	ldi	r30, 0x55	; 85
  58:	f0 e0       	ldi	r31, 0x00	; 0
  5a:	80 81       	ld	r24, Z
  5c:	83 7f       	andi	r24, 0xF3	; 243
  5e:	8c 93       	st	X, r24
  60:	ab e5       	ldi	r26, 0x5B	; 91
  62:	b0 e0       	ldi	r27, 0x00	; 0
  64:	eb e5       	ldi	r30, 0x5B	; 91
  66:	f0 e0       	ldi	r31, 0x00	; 0
  68:	80 81       	ld	r24, Z
  6a:	8f 77       	andi	r24, 0x7F	; 127
  6c:	8c 93       	st	X, r24
  6e:	00 c0       	rjmp	.+0      	; 0x70 <external_interrupt_deinit+0x70>
  70:	a4 e5       	ldi	r26, 0x54	; 84
  72:	b0 e0       	ldi	r27, 0x00	; 0
  74:	e4 e5       	ldi	r30, 0x54	; 84
  76:	f0 e0       	ldi	r31, 0x00	; 0
  78:	80 81       	ld	r24, Z
  7a:	8f 7b       	andi	r24, 0xBF	; 191
  7c:	8c 93       	st	X, r24
  7e:	ab e5       	ldi	r26, 0x5B	; 91
  80:	b0 e0       	ldi	r27, 0x00	; 0
  82:	eb e5       	ldi	r30, 0x5B	; 91
  84:	f0 e0       	ldi	r31, 0x00	; 0
  86:	80 81       	ld	r24, Z
  88:	8f 7d       	andi	r24, 0xDF	; 223
  8a:	8c 93       	st	X, r24
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	cf 91       	pop	r28
  94:	df 91       	pop	r29
  96:	08 95       	ret

Disassembly of section .text.external_interrupt_setCallBack:

00000000 <external_interrupt_setCallBack>:
/*
 * ISR for INT0.
 * This ISR is called when an interrupt is triggered on INT0.
 */
ISR(INT0_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <external_interrupt_setCallBack+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <external_interrupt_setCallBack+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9a 83       	std	Y+2, r25	; 0x02
  10:	89 83       	std	Y+1, r24	; 0x01
  12:	6b 83       	std	Y+3, r22	; 0x03
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3d 83       	std	Y+5, r19	; 0x05
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <external_interrupt_setCallBack+0x28>
  28:	2c 81       	ldd	r18, Y+4	; 0x04
    if(g_callBackPtr_INT0 != NULL_PTR)
  2a:	3d 81       	ldd	r19, Y+5	; 0x05
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	01 f0       	breq	.+0      	; 0x32 <external_interrupt_setCallBack+0x32>
  32:	8c 81       	ldd	r24, Y+4	; 0x04
  34:	9d 81       	ldd	r25, Y+5	; 0x05
    {
        /* Call the Call Back function in the application after the edge is detected */
        (*g_callBackPtr_INT0)();
  36:	00 97       	sbiw	r24, 0x00	; 0
  38:	01 f4       	brne	.+0      	; 0x3a <external_interrupt_setCallBack+0x3a>
  3a:	89 81       	ldd	r24, Y+1	; 0x01
  3c:	9a 81       	ldd	r25, Y+2	; 0x02
  3e:	90 93 00 00 	sts	0x0000, r25
    }
}
  42:	80 93 00 00 	sts	0x0000, r24
  46:	00 c0       	rjmp	.+0      	; 0x48 <external_interrupt_setCallBack+0x48>
  48:	89 81       	ldd	r24, Y+1	; 0x01
  4a:	9a 81       	ldd	r25, Y+2	; 0x02
  4c:	90 93 00 00 	sts	0x0000, r25
  50:	80 93 00 00 	sts	0x0000, r24
  54:	00 c0       	rjmp	.+0      	; 0x56 <external_interrupt_setCallBack+0x56>
  56:	89 81       	ldd	r24, Y+1	; 0x01
  58:	9a 81       	ldd	r25, Y+2	; 0x02
  5a:	90 93 00 00 	sts	0x0000, r25
  5e:	80 93 00 00 	sts	0x0000, r24
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
  6a:	0f 90       	pop	r0
  6c:	cf 91       	pop	r28
  6e:	df 91       	pop	r29
  70:	08 95       	ret

gpio.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000864  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000098b  00000000  00000000  00000898  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.GPIO_setupPinDirection 000001d6  00000000  00000000  00001223  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.GPIO_writePin 000001d6  00000000  00000000  000013f9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.GPIO_readPin 00000136  00000000  00000000  000015cf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.GPIO_setupPortDirection 00000088  00000000  00000000  00001705  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.GPIO_writePort 00000088  00000000  00000000  0000178d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.GPIO_readPort 0000008a  00000000  00000000  00001815  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.GPIO_setupPinDirection:

00000000 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPIO_setupPinDirection+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <GPIO_setupPinDirection+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6a 83       	std	Y+2, r22	; 0x02
  12:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	88 30       	cpi	r24, 0x08	; 8
  18:	00 f0       	brcs	.+0      	; 0x1a <GPIO_setupPinDirection+0x1a>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <GPIO_setupPinDirection+0x1c>
  1c:	89 81       	ldd	r24, Y+1	; 0x01
  1e:	84 30       	cpi	r24, 0x04	; 4
  20:	00 f0       	brcs	.+0      	; 0x22 <GPIO_setupPinDirection+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <GPIO_setupPinDirection+0x24>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
  24:	89 81       	ldd	r24, Y+1	; 0x01
  26:	28 2f       	mov	r18, r24
  28:	30 e0       	ldi	r19, 0x00	; 0
  2a:	3d 83       	std	Y+5, r19	; 0x05
  2c:	2c 83       	std	Y+4, r18	; 0x04
  2e:	8c 81       	ldd	r24, Y+4	; 0x04
  30:	9d 81       	ldd	r25, Y+5	; 0x05
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	91 05       	cpc	r25, r1
  36:	01 f4       	brne	.+0      	; 0x38 <GPIO_setupPinDirection+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <GPIO_setupPinDirection+0x3a>
  3a:	2c 81       	ldd	r18, Y+4	; 0x04
  3c:	3d 81       	ldd	r19, Y+5	; 0x05
  3e:	22 30       	cpi	r18, 0x02	; 2
  40:	31 05       	cpc	r19, r1
  42:	04 f4       	brge	.+0      	; 0x44 <GPIO_setupPinDirection+0x44>
  44:	8c 81       	ldd	r24, Y+4	; 0x04
  46:	9d 81       	ldd	r25, Y+5	; 0x05
  48:	00 97       	sbiw	r24, 0x00	; 0
  4a:	01 f0       	breq	.+0      	; 0x4c <GPIO_setupPinDirection+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <GPIO_setupPinDirection+0x4e>
  4e:	2c 81       	ldd	r18, Y+4	; 0x04
  50:	3d 81       	ldd	r19, Y+5	; 0x05
  52:	22 30       	cpi	r18, 0x02	; 2
  54:	31 05       	cpc	r19, r1
  56:	01 f4       	brne	.+0      	; 0x58 <GPIO_setupPinDirection+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <GPIO_setupPinDirection+0x5a>
  5a:	8c 81       	ldd	r24, Y+4	; 0x04
  5c:	9d 81       	ldd	r25, Y+5	; 0x05
  5e:	83 30       	cpi	r24, 0x03	; 3
  60:	91 05       	cpc	r25, r1
  62:	01 f4       	brne	.+0      	; 0x64 <GPIO_setupPinDirection+0x64>
  64:	00 c0       	rjmp	.+0      	; 0x66 <GPIO_setupPinDirection+0x66>
  66:	00 c0       	rjmp	.+0      	; 0x68 <GPIO_setupPinDirection+0x68>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
  68:	8b 81       	ldd	r24, Y+3	; 0x03
  6a:	81 30       	cpi	r24, 0x01	; 1
  6c:	01 f4       	brne	.+0      	; 0x6e <GPIO_setupPinDirection+0x6e>
			{
				SET_BIT(DDRA,pin_num);
  6e:	aa e3       	ldi	r26, 0x3A	; 58
  70:	b0 e0       	ldi	r27, 0x00	; 0
  72:	ea e3       	ldi	r30, 0x3A	; 58
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	80 81       	ld	r24, Z
  78:	48 2f       	mov	r20, r24
  7a:	8a 81       	ldd	r24, Y+2	; 0x02
  7c:	28 2f       	mov	r18, r24
  7e:	30 e0       	ldi	r19, 0x00	; 0
  80:	81 e0       	ldi	r24, 0x01	; 1
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	02 2e       	mov	r0, r18
  86:	00 c0       	rjmp	.+0      	; 0x88 <GPIO_setupPinDirection+0x88>
  88:	88 0f       	add	r24, r24
  8a:	99 1f       	adc	r25, r25
  8c:	0a 94       	dec	r0
  8e:	02 f4       	brpl	.+0      	; 0x90 <GPIO_setupPinDirection+0x90>
  90:	84 2b       	or	r24, r20
  92:	8c 93       	st	X, r24
  94:	00 c0       	rjmp	.+0      	; 0x96 <GPIO_setupPinDirection+0x96>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
  96:	aa e3       	ldi	r26, 0x3A	; 58
  98:	b0 e0       	ldi	r27, 0x00	; 0
  9a:	ea e3       	ldi	r30, 0x3A	; 58
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	48 2f       	mov	r20, r24
  a2:	8a 81       	ldd	r24, Y+2	; 0x02
  a4:	28 2f       	mov	r18, r24
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 2e       	mov	r0, r18
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <GPIO_setupPinDirection+0xb0>
  b0:	88 0f       	add	r24, r24
  b2:	99 1f       	adc	r25, r25
  b4:	0a 94       	dec	r0
  b6:	02 f4       	brpl	.+0      	; 0xb8 <GPIO_setupPinDirection+0xb8>
  b8:	80 95       	com	r24
  ba:	84 23       	and	r24, r20
  bc:	8c 93       	st	X, r24
  be:	00 c0       	rjmp	.+0      	; 0xc0 <GPIO_setupPinDirection+0xc0>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
  c0:	8b 81       	ldd	r24, Y+3	; 0x03
  c2:	81 30       	cpi	r24, 0x01	; 1
  c4:	01 f4       	brne	.+0      	; 0xc6 <GPIO_setupPinDirection+0xc6>
			{
				SET_BIT(DDRB,pin_num);
  c6:	a7 e3       	ldi	r26, 0x37	; 55
  c8:	b0 e0       	ldi	r27, 0x00	; 0
  ca:	e7 e3       	ldi	r30, 0x37	; 55
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	80 81       	ld	r24, Z
  d0:	48 2f       	mov	r20, r24
  d2:	8a 81       	ldd	r24, Y+2	; 0x02
  d4:	28 2f       	mov	r18, r24
  d6:	30 e0       	ldi	r19, 0x00	; 0
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	02 2e       	mov	r0, r18
  de:	00 c0       	rjmp	.+0      	; 0xe0 <GPIO_setupPinDirection+0xe0>
  e0:	88 0f       	add	r24, r24
  e2:	99 1f       	adc	r25, r25
  e4:	0a 94       	dec	r0
  e6:	02 f4       	brpl	.+0      	; 0xe8 <GPIO_setupPinDirection+0xe8>
  e8:	84 2b       	or	r24, r20
  ea:	8c 93       	st	X, r24
  ec:	00 c0       	rjmp	.+0      	; 0xee <GPIO_setupPinDirection+0xee>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
  ee:	a7 e3       	ldi	r26, 0x37	; 55
  f0:	b0 e0       	ldi	r27, 0x00	; 0
  f2:	e7 e3       	ldi	r30, 0x37	; 55
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	80 81       	ld	r24, Z
  f8:	48 2f       	mov	r20, r24
  fa:	8a 81       	ldd	r24, Y+2	; 0x02
  fc:	28 2f       	mov	r18, r24
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	02 2e       	mov	r0, r18
 106:	00 c0       	rjmp	.+0      	; 0x108 <GPIO_setupPinDirection+0x108>
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	0a 94       	dec	r0
 10e:	02 f4       	brpl	.+0      	; 0x110 <GPIO_setupPinDirection+0x110>
 110:	80 95       	com	r24
 112:	84 23       	and	r24, r20
 114:	8c 93       	st	X, r24
 116:	00 c0       	rjmp	.+0      	; 0x118 <GPIO_setupPinDirection+0x118>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
 118:	8b 81       	ldd	r24, Y+3	; 0x03
 11a:	81 30       	cpi	r24, 0x01	; 1
 11c:	01 f4       	brne	.+0      	; 0x11e <GPIO_setupPinDirection+0x11e>
			{
				SET_BIT(DDRC,pin_num);
 11e:	a4 e3       	ldi	r26, 0x34	; 52
 120:	b0 e0       	ldi	r27, 0x00	; 0
 122:	e4 e3       	ldi	r30, 0x34	; 52
 124:	f0 e0       	ldi	r31, 0x00	; 0
 126:	80 81       	ld	r24, Z
 128:	48 2f       	mov	r20, r24
 12a:	8a 81       	ldd	r24, Y+2	; 0x02
 12c:	28 2f       	mov	r18, r24
 12e:	30 e0       	ldi	r19, 0x00	; 0
 130:	81 e0       	ldi	r24, 0x01	; 1
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	02 2e       	mov	r0, r18
 136:	00 c0       	rjmp	.+0      	; 0x138 <GPIO_setupPinDirection+0x138>
 138:	88 0f       	add	r24, r24
 13a:	99 1f       	adc	r25, r25
 13c:	0a 94       	dec	r0
 13e:	02 f4       	brpl	.+0      	; 0x140 <GPIO_setupPinDirection+0x140>
 140:	84 2b       	or	r24, r20
 142:	8c 93       	st	X, r24
 144:	00 c0       	rjmp	.+0      	; 0x146 <GPIO_setupPinDirection+0x146>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
 146:	a4 e3       	ldi	r26, 0x34	; 52
 148:	b0 e0       	ldi	r27, 0x00	; 0
 14a:	e4 e3       	ldi	r30, 0x34	; 52
 14c:	f0 e0       	ldi	r31, 0x00	; 0
 14e:	80 81       	ld	r24, Z
 150:	48 2f       	mov	r20, r24
 152:	8a 81       	ldd	r24, Y+2	; 0x02
 154:	28 2f       	mov	r18, r24
 156:	30 e0       	ldi	r19, 0x00	; 0
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	02 2e       	mov	r0, r18
 15e:	00 c0       	rjmp	.+0      	; 0x160 <GPIO_setupPinDirection+0x160>
 160:	88 0f       	add	r24, r24
 162:	99 1f       	adc	r25, r25
 164:	0a 94       	dec	r0
 166:	02 f4       	brpl	.+0      	; 0x168 <GPIO_setupPinDirection+0x168>
 168:	80 95       	com	r24
 16a:	84 23       	and	r24, r20
 16c:	8c 93       	st	X, r24
 16e:	00 c0       	rjmp	.+0      	; 0x170 <GPIO_setupPinDirection+0x170>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
 170:	8b 81       	ldd	r24, Y+3	; 0x03
 172:	81 30       	cpi	r24, 0x01	; 1
 174:	01 f4       	brne	.+0      	; 0x176 <GPIO_setupPinDirection+0x176>
			{
				SET_BIT(DDRD,pin_num);
 176:	a1 e3       	ldi	r26, 0x31	; 49
 178:	b0 e0       	ldi	r27, 0x00	; 0
 17a:	e1 e3       	ldi	r30, 0x31	; 49
 17c:	f0 e0       	ldi	r31, 0x00	; 0
 17e:	80 81       	ld	r24, Z
 180:	48 2f       	mov	r20, r24
 182:	8a 81       	ldd	r24, Y+2	; 0x02
 184:	28 2f       	mov	r18, r24
 186:	30 e0       	ldi	r19, 0x00	; 0
 188:	81 e0       	ldi	r24, 0x01	; 1
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	02 2e       	mov	r0, r18
 18e:	00 c0       	rjmp	.+0      	; 0x190 <GPIO_setupPinDirection+0x190>
 190:	88 0f       	add	r24, r24
 192:	99 1f       	adc	r25, r25
 194:	0a 94       	dec	r0
 196:	02 f4       	brpl	.+0      	; 0x198 <GPIO_setupPinDirection+0x198>
 198:	84 2b       	or	r24, r20
 19a:	8c 93       	st	X, r24
 19c:	00 c0       	rjmp	.+0      	; 0x19e <GPIO_setupPinDirection+0x19e>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
 19e:	a1 e3       	ldi	r26, 0x31	; 49
 1a0:	b0 e0       	ldi	r27, 0x00	; 0
 1a2:	e1 e3       	ldi	r30, 0x31	; 49
 1a4:	f0 e0       	ldi	r31, 0x00	; 0
 1a6:	80 81       	ld	r24, Z
 1a8:	48 2f       	mov	r20, r24
 1aa:	8a 81       	ldd	r24, Y+2	; 0x02
 1ac:	28 2f       	mov	r18, r24
 1ae:	30 e0       	ldi	r19, 0x00	; 0
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	90 e0       	ldi	r25, 0x00	; 0
 1b4:	02 2e       	mov	r0, r18
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <GPIO_setupPinDirection+0x1b8>
 1b8:	88 0f       	add	r24, r24
 1ba:	99 1f       	adc	r25, r25
 1bc:	0a 94       	dec	r0
 1be:	02 f4       	brpl	.+0      	; 0x1c0 <GPIO_setupPinDirection+0x1c0>
 1c0:	80 95       	com	r24
 1c2:	84 23       	and	r24, r20
 1c4:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
 1c6:	0f 90       	pop	r0
 1c8:	0f 90       	pop	r0
 1ca:	0f 90       	pop	r0
 1cc:	0f 90       	pop	r0
 1ce:	0f 90       	pop	r0
 1d0:	cf 91       	pop	r28
 1d2:	df 91       	pop	r29
 1d4:	08 95       	ret

Disassembly of section .text.GPIO_writePin:

00000000 <GPIO_writePin>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPIO_writePin+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <GPIO_writePin+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6a 83       	std	Y+2, r22	; 0x02
  12:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	88 30       	cpi	r24, 0x08	; 8
  18:	00 f0       	brcs	.+0      	; 0x1a <GPIO_writePin+0x1a>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <GPIO_writePin+0x1c>
  1c:	89 81       	ldd	r24, Y+1	; 0x01
  1e:	84 30       	cpi	r24, 0x04	; 4
  20:	00 f0       	brcs	.+0      	; 0x22 <GPIO_writePin+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <GPIO_writePin+0x24>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
  24:	89 81       	ldd	r24, Y+1	; 0x01
  26:	28 2f       	mov	r18, r24
  28:	30 e0       	ldi	r19, 0x00	; 0
  2a:	3d 83       	std	Y+5, r19	; 0x05
  2c:	2c 83       	std	Y+4, r18	; 0x04
  2e:	8c 81       	ldd	r24, Y+4	; 0x04
  30:	9d 81       	ldd	r25, Y+5	; 0x05
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	91 05       	cpc	r25, r1
  36:	01 f4       	brne	.+0      	; 0x38 <GPIO_writePin+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <GPIO_writePin+0x3a>
  3a:	2c 81       	ldd	r18, Y+4	; 0x04
  3c:	3d 81       	ldd	r19, Y+5	; 0x05
  3e:	22 30       	cpi	r18, 0x02	; 2
  40:	31 05       	cpc	r19, r1
  42:	04 f4       	brge	.+0      	; 0x44 <GPIO_writePin+0x44>
  44:	8c 81       	ldd	r24, Y+4	; 0x04
  46:	9d 81       	ldd	r25, Y+5	; 0x05
  48:	00 97       	sbiw	r24, 0x00	; 0
  4a:	01 f0       	breq	.+0      	; 0x4c <GPIO_writePin+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <GPIO_writePin+0x4e>
  4e:	2c 81       	ldd	r18, Y+4	; 0x04
  50:	3d 81       	ldd	r19, Y+5	; 0x05
  52:	22 30       	cpi	r18, 0x02	; 2
  54:	31 05       	cpc	r19, r1
  56:	01 f4       	brne	.+0      	; 0x58 <GPIO_writePin+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <GPIO_writePin+0x5a>
  5a:	8c 81       	ldd	r24, Y+4	; 0x04
  5c:	9d 81       	ldd	r25, Y+5	; 0x05
  5e:	83 30       	cpi	r24, 0x03	; 3
  60:	91 05       	cpc	r25, r1
  62:	01 f4       	brne	.+0      	; 0x64 <GPIO_writePin+0x64>
  64:	00 c0       	rjmp	.+0      	; 0x66 <GPIO_writePin+0x66>
  66:	00 c0       	rjmp	.+0      	; 0x68 <GPIO_writePin+0x68>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
  68:	8b 81       	ldd	r24, Y+3	; 0x03
  6a:	81 30       	cpi	r24, 0x01	; 1
  6c:	01 f4       	brne	.+0      	; 0x6e <GPIO_writePin+0x6e>
			{
				SET_BIT(DDRA,pin_num);
  6e:	ab e3       	ldi	r26, 0x3B	; 59
  70:	b0 e0       	ldi	r27, 0x00	; 0
  72:	eb e3       	ldi	r30, 0x3B	; 59
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	80 81       	ld	r24, Z
  78:	48 2f       	mov	r20, r24
  7a:	8a 81       	ldd	r24, Y+2	; 0x02
  7c:	28 2f       	mov	r18, r24
  7e:	30 e0       	ldi	r19, 0x00	; 0
  80:	81 e0       	ldi	r24, 0x01	; 1
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	02 2e       	mov	r0, r18
  86:	00 c0       	rjmp	.+0      	; 0x88 <GPIO_writePin+0x88>
  88:	88 0f       	add	r24, r24
  8a:	99 1f       	adc	r25, r25
  8c:	0a 94       	dec	r0
  8e:	02 f4       	brpl	.+0      	; 0x90 <GPIO_writePin+0x90>
  90:	84 2b       	or	r24, r20
  92:	8c 93       	st	X, r24
  94:	00 c0       	rjmp	.+0      	; 0x96 <GPIO_writePin+0x96>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
  96:	ab e3       	ldi	r26, 0x3B	; 59
  98:	b0 e0       	ldi	r27, 0x00	; 0
  9a:	eb e3       	ldi	r30, 0x3B	; 59
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	48 2f       	mov	r20, r24
  a2:	8a 81       	ldd	r24, Y+2	; 0x02
  a4:	28 2f       	mov	r18, r24
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 2e       	mov	r0, r18
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <GPIO_writePin+0xb0>
  b0:	88 0f       	add	r24, r24
  b2:	99 1f       	adc	r25, r25
  b4:	0a 94       	dec	r0
  b6:	02 f4       	brpl	.+0      	; 0xb8 <GPIO_writePin+0xb8>
  b8:	80 95       	com	r24
  ba:	84 23       	and	r24, r20
  bc:	8c 93       	st	X, r24
  be:	00 c0       	rjmp	.+0      	; 0xc0 <GPIO_writePin+0xc0>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
  c0:	8b 81       	ldd	r24, Y+3	; 0x03
  c2:	81 30       	cpi	r24, 0x01	; 1
  c4:	01 f4       	brne	.+0      	; 0xc6 <GPIO_writePin+0xc6>
			{
				SET_BIT(DDRB,pin_num);
  c6:	a8 e3       	ldi	r26, 0x38	; 56
  c8:	b0 e0       	ldi	r27, 0x00	; 0
  ca:	e8 e3       	ldi	r30, 0x38	; 56
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	80 81       	ld	r24, Z
  d0:	48 2f       	mov	r20, r24
  d2:	8a 81       	ldd	r24, Y+2	; 0x02
  d4:	28 2f       	mov	r18, r24
  d6:	30 e0       	ldi	r19, 0x00	; 0
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	02 2e       	mov	r0, r18
  de:	00 c0       	rjmp	.+0      	; 0xe0 <GPIO_writePin+0xe0>
  e0:	88 0f       	add	r24, r24
  e2:	99 1f       	adc	r25, r25
  e4:	0a 94       	dec	r0
  e6:	02 f4       	brpl	.+0      	; 0xe8 <GPIO_writePin+0xe8>
  e8:	84 2b       	or	r24, r20
  ea:	8c 93       	st	X, r24
  ec:	00 c0       	rjmp	.+0      	; 0xee <GPIO_writePin+0xee>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
  ee:	a8 e3       	ldi	r26, 0x38	; 56
  f0:	b0 e0       	ldi	r27, 0x00	; 0
  f2:	e8 e3       	ldi	r30, 0x38	; 56
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	80 81       	ld	r24, Z
  f8:	48 2f       	mov	r20, r24
  fa:	8a 81       	ldd	r24, Y+2	; 0x02
  fc:	28 2f       	mov	r18, r24
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	02 2e       	mov	r0, r18
 106:	00 c0       	rjmp	.+0      	; 0x108 <GPIO_writePin+0x108>
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	0a 94       	dec	r0
 10e:	02 f4       	brpl	.+0      	; 0x110 <GPIO_writePin+0x110>
 110:	80 95       	com	r24
 112:	84 23       	and	r24, r20
 114:	8c 93       	st	X, r24
 116:	00 c0       	rjmp	.+0      	; 0x118 <GPIO_writePin+0x118>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
 118:	8b 81       	ldd	r24, Y+3	; 0x03
 11a:	81 30       	cpi	r24, 0x01	; 1
 11c:	01 f4       	brne	.+0      	; 0x11e <GPIO_writePin+0x11e>
			{
				SET_BIT(DDRC,pin_num);
 11e:	a5 e3       	ldi	r26, 0x35	; 53
 120:	b0 e0       	ldi	r27, 0x00	; 0
 122:	e5 e3       	ldi	r30, 0x35	; 53
 124:	f0 e0       	ldi	r31, 0x00	; 0
 126:	80 81       	ld	r24, Z
 128:	48 2f       	mov	r20, r24
 12a:	8a 81       	ldd	r24, Y+2	; 0x02
 12c:	28 2f       	mov	r18, r24
 12e:	30 e0       	ldi	r19, 0x00	; 0
 130:	81 e0       	ldi	r24, 0x01	; 1
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	02 2e       	mov	r0, r18
 136:	00 c0       	rjmp	.+0      	; 0x138 <GPIO_writePin+0x138>
 138:	88 0f       	add	r24, r24
 13a:	99 1f       	adc	r25, r25
 13c:	0a 94       	dec	r0
 13e:	02 f4       	brpl	.+0      	; 0x140 <GPIO_writePin+0x140>
 140:	84 2b       	or	r24, r20
 142:	8c 93       	st	X, r24
 144:	00 c0       	rjmp	.+0      	; 0x146 <GPIO_writePin+0x146>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
 146:	a5 e3       	ldi	r26, 0x35	; 53
 148:	b0 e0       	ldi	r27, 0x00	; 0
 14a:	e5 e3       	ldi	r30, 0x35	; 53
 14c:	f0 e0       	ldi	r31, 0x00	; 0
 14e:	80 81       	ld	r24, Z
 150:	48 2f       	mov	r20, r24
 152:	8a 81       	ldd	r24, Y+2	; 0x02
 154:	28 2f       	mov	r18, r24
 156:	30 e0       	ldi	r19, 0x00	; 0
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	02 2e       	mov	r0, r18
 15e:	00 c0       	rjmp	.+0      	; 0x160 <GPIO_writePin+0x160>
 160:	88 0f       	add	r24, r24
 162:	99 1f       	adc	r25, r25
 164:	0a 94       	dec	r0
 166:	02 f4       	brpl	.+0      	; 0x168 <GPIO_writePin+0x168>
 168:	80 95       	com	r24
 16a:	84 23       	and	r24, r20
 16c:	8c 93       	st	X, r24
 16e:	00 c0       	rjmp	.+0      	; 0x170 <GPIO_writePin+0x170>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
 170:	8b 81       	ldd	r24, Y+3	; 0x03
 172:	81 30       	cpi	r24, 0x01	; 1
 174:	01 f4       	brne	.+0      	; 0x176 <GPIO_writePin+0x176>
			{
				SET_BIT(DDRD,pin_num);
 176:	a2 e3       	ldi	r26, 0x32	; 50
 178:	b0 e0       	ldi	r27, 0x00	; 0
 17a:	e2 e3       	ldi	r30, 0x32	; 50
 17c:	f0 e0       	ldi	r31, 0x00	; 0
 17e:	80 81       	ld	r24, Z
 180:	48 2f       	mov	r20, r24
 182:	8a 81       	ldd	r24, Y+2	; 0x02
 184:	28 2f       	mov	r18, r24
 186:	30 e0       	ldi	r19, 0x00	; 0
 188:	81 e0       	ldi	r24, 0x01	; 1
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	02 2e       	mov	r0, r18
 18e:	00 c0       	rjmp	.+0      	; 0x190 <GPIO_writePin+0x190>
 190:	88 0f       	add	r24, r24
 192:	99 1f       	adc	r25, r25
 194:	0a 94       	dec	r0
 196:	02 f4       	brpl	.+0      	; 0x198 <GPIO_writePin+0x198>
 198:	84 2b       	or	r24, r20
 19a:	8c 93       	st	X, r24
 19c:	00 c0       	rjmp	.+0      	; 0x19e <GPIO_writePin+0x19e>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
 19e:	a2 e3       	ldi	r26, 0x32	; 50
 1a0:	b0 e0       	ldi	r27, 0x00	; 0
 1a2:	e2 e3       	ldi	r30, 0x32	; 50
 1a4:	f0 e0       	ldi	r31, 0x00	; 0
 1a6:	80 81       	ld	r24, Z
 1a8:	48 2f       	mov	r20, r24
 1aa:	8a 81       	ldd	r24, Y+2	; 0x02
 1ac:	28 2f       	mov	r18, r24
 1ae:	30 e0       	ldi	r19, 0x00	; 0
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	90 e0       	ldi	r25, 0x00	; 0
 1b4:	02 2e       	mov	r0, r18
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <GPIO_writePin+0x1b8>
 1b8:	88 0f       	add	r24, r24
 1ba:	99 1f       	adc	r25, r25
 1bc:	0a 94       	dec	r0
 1be:	02 f4       	brpl	.+0      	; 0x1c0 <GPIO_writePin+0x1c0>
 1c0:	80 95       	com	r24
 1c2:	84 23       	and	r24, r20
 1c4:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
 1c6:	0f 90       	pop	r0
 1c8:	0f 90       	pop	r0
 1ca:	0f 90       	pop	r0
 1cc:	0f 90       	pop	r0
 1ce:	0f 90       	pop	r0
 1d0:	cf 91       	pop	r28
 1d2:	df 91       	pop	r29
 1d4:	08 95       	ret

Disassembly of section .text.GPIO_readPin:

00000000 <GPIO_readPin>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPIO_readPin+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <GPIO_readPin+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	88 30       	cpi	r24, 0x08	; 8
  18:	00 f0       	brcs	.+0      	; 0x1a <GPIO_readPin+0x1a>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <GPIO_readPin+0x1c>
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	84 30       	cpi	r24, 0x04	; 4
  20:	00 f0       	brcs	.+0      	; 0x22 <GPIO_readPin+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <GPIO_readPin+0x24>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
  24:	8a 81       	ldd	r24, Y+2	; 0x02
  26:	28 2f       	mov	r18, r24
  28:	30 e0       	ldi	r19, 0x00	; 0
  2a:	3d 83       	std	Y+5, r19	; 0x05
  2c:	2c 83       	std	Y+4, r18	; 0x04
  2e:	4c 81       	ldd	r20, Y+4	; 0x04
  30:	5d 81       	ldd	r21, Y+5	; 0x05
  32:	41 30       	cpi	r20, 0x01	; 1
  34:	51 05       	cpc	r21, r1
  36:	01 f0       	breq	.+0      	; 0x38 <GPIO_readPin+0x38>
  38:	8c 81       	ldd	r24, Y+4	; 0x04
  3a:	9d 81       	ldd	r25, Y+5	; 0x05
  3c:	82 30       	cpi	r24, 0x02	; 2
  3e:	91 05       	cpc	r25, r1
  40:	04 f4       	brge	.+0      	; 0x42 <GPIO_readPin+0x42>
  42:	2c 81       	ldd	r18, Y+4	; 0x04
  44:	3d 81       	ldd	r19, Y+5	; 0x05
  46:	21 15       	cp	r18, r1
  48:	31 05       	cpc	r19, r1
  4a:	01 f0       	breq	.+0      	; 0x4c <GPIO_readPin+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <GPIO_readPin+0x4e>
  4e:	4c 81       	ldd	r20, Y+4	; 0x04
  50:	5d 81       	ldd	r21, Y+5	; 0x05
  52:	42 30       	cpi	r20, 0x02	; 2
  54:	51 05       	cpc	r21, r1
  56:	01 f0       	breq	.+0      	; 0x58 <GPIO_readPin+0x58>
  58:	8c 81       	ldd	r24, Y+4	; 0x04
  5a:	9d 81       	ldd	r25, Y+5	; 0x05
  5c:	83 30       	cpi	r24, 0x03	; 3
  5e:	91 05       	cpc	r25, r1
  60:	01 f4       	brne	.+0      	; 0x62 <GPIO_readPin+0x62>
  62:	00 c0       	rjmp	.+0      	; 0x64 <GPIO_readPin+0x64>
  64:	00 c0       	rjmp	.+0      	; 0x66 <GPIO_readPin+0x66>
  66:	e9 e3       	ldi	r30, 0x39	; 57
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	80 81       	ld	r24, Z
  6c:	28 2f       	mov	r18, r24
			{
				SET_BIT(DDRA,pin_num);
  6e:	30 e0       	ldi	r19, 0x00	; 0
  70:	8b 81       	ldd	r24, Y+3	; 0x03
  72:	88 2f       	mov	r24, r24
  74:	90 e0       	ldi	r25, 0x00	; 0
  76:	a9 01       	movw	r20, r18
  78:	00 c0       	rjmp	.+0      	; 0x7a <GPIO_readPin+0x7a>
  7a:	55 95       	asr	r21
  7c:	47 95       	ror	r20
  7e:	8a 95       	dec	r24
  80:	02 f4       	brpl	.+0      	; 0x82 <GPIO_readPin+0x82>
  82:	ca 01       	movw	r24, r20
  84:	81 70       	andi	r24, 0x01	; 1
  86:	90 70       	andi	r25, 0x00	; 0
  88:	88 23       	and	r24, r24
  8a:	01 f0       	breq	.+0      	; 0x8c <GPIO_readPin+0x8c>
  8c:	81 e0       	ldi	r24, 0x01	; 1
  8e:	89 83       	std	Y+1, r24	; 0x01
  90:	00 c0       	rjmp	.+0      	; 0x92 <GPIO_readPin+0x92>
  92:	19 82       	std	Y+1, r1	; 0x01
  94:	00 c0       	rjmp	.+0      	; 0x96 <GPIO_readPin+0x96>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
  96:	e6 e3       	ldi	r30, 0x36	; 54
  98:	f0 e0       	ldi	r31, 0x00	; 0
  9a:	80 81       	ld	r24, Z
  9c:	28 2f       	mov	r18, r24
  9e:	30 e0       	ldi	r19, 0x00	; 0
  a0:	8b 81       	ldd	r24, Y+3	; 0x03
  a2:	88 2f       	mov	r24, r24
  a4:	90 e0       	ldi	r25, 0x00	; 0
  a6:	a9 01       	movw	r20, r18
  a8:	00 c0       	rjmp	.+0      	; 0xaa <GPIO_readPin+0xaa>
  aa:	55 95       	asr	r21
  ac:	47 95       	ror	r20
  ae:	8a 95       	dec	r24
  b0:	02 f4       	brpl	.+0      	; 0xb2 <GPIO_readPin+0xb2>
  b2:	ca 01       	movw	r24, r20
  b4:	81 70       	andi	r24, 0x01	; 1
  b6:	90 70       	andi	r25, 0x00	; 0
  b8:	88 23       	and	r24, r24
  ba:	01 f0       	breq	.+0      	; 0xbc <GPIO_readPin+0xbc>
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	89 83       	std	Y+1, r24	; 0x01
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <GPIO_readPin+0xc2>
  c2:	19 82       	std	Y+1, r1	; 0x01
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <GPIO_readPin+0xc6>
			{
				SET_BIT(DDRB,pin_num);
  c6:	e3 e3       	ldi	r30, 0x33	; 51
  c8:	f0 e0       	ldi	r31, 0x00	; 0
  ca:	80 81       	ld	r24, Z
  cc:	28 2f       	mov	r18, r24
  ce:	30 e0       	ldi	r19, 0x00	; 0
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	88 2f       	mov	r24, r24
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	a9 01       	movw	r20, r18
  d8:	00 c0       	rjmp	.+0      	; 0xda <GPIO_readPin+0xda>
  da:	55 95       	asr	r21
  dc:	47 95       	ror	r20
  de:	8a 95       	dec	r24
  e0:	02 f4       	brpl	.+0      	; 0xe2 <GPIO_readPin+0xe2>
  e2:	ca 01       	movw	r24, r20
  e4:	81 70       	andi	r24, 0x01	; 1
  e6:	90 70       	andi	r25, 0x00	; 0
  e8:	88 23       	and	r24, r24
  ea:	01 f0       	breq	.+0      	; 0xec <GPIO_readPin+0xec>
  ec:	81 e0       	ldi	r24, 0x01	; 1
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
  ee:	89 83       	std	Y+1, r24	; 0x01
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <GPIO_readPin+0xf2>
  f2:	19 82       	std	Y+1, r1	; 0x01
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <GPIO_readPin+0xf6>
  f6:	e0 e3       	ldi	r30, 0x30	; 48
  f8:	f0 e0       	ldi	r31, 0x00	; 0
  fa:	80 81       	ld	r24, Z
  fc:	28 2f       	mov	r18, r24
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	8b 81       	ldd	r24, Y+3	; 0x03
 102:	88 2f       	mov	r24, r24
 104:	90 e0       	ldi	r25, 0x00	; 0
 106:	a9 01       	movw	r20, r18
 108:	00 c0       	rjmp	.+0      	; 0x10a <GPIO_readPin+0x10a>
 10a:	55 95       	asr	r21
 10c:	47 95       	ror	r20
 10e:	8a 95       	dec	r24
 110:	02 f4       	brpl	.+0      	; 0x112 <GPIO_readPin+0x112>
 112:	ca 01       	movw	r24, r20
 114:	81 70       	andi	r24, 0x01	; 1
 116:	90 70       	andi	r25, 0x00	; 0
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
 118:	88 23       	and	r24, r24
 11a:	01 f0       	breq	.+0      	; 0x11c <GPIO_readPin+0x11c>
 11c:	81 e0       	ldi	r24, 0x01	; 1
			{
				SET_BIT(DDRC,pin_num);
 11e:	89 83       	std	Y+1, r24	; 0x01
 120:	00 c0       	rjmp	.+0      	; 0x122 <GPIO_readPin+0x122>
 122:	19 82       	std	Y+1, r1	; 0x01
 124:	89 81       	ldd	r24, Y+1	; 0x01
 126:	0f 90       	pop	r0
 128:	0f 90       	pop	r0
 12a:	0f 90       	pop	r0
 12c:	0f 90       	pop	r0
 12e:	0f 90       	pop	r0
 130:	cf 91       	pop	r28
 132:	df 91       	pop	r29
 134:	08 95       	ret

Disassembly of section .text.GPIO_setupPortDirection:

00000000 <GPIO_setupPortDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPIO_setupPortDirection+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <GPIO_setupPortDirection+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	84 30       	cpi	r24, 0x04	; 4
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
  14:	00 f4       	brcc	.+0      	; 0x16 <GPIO_setupPortDirection+0x16>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3c 83       	std	Y+4, r19	; 0x04
  1e:	2b 83       	std	Y+3, r18	; 0x03
  20:	8b 81       	ldd	r24, Y+3	; 0x03
  22:	9c 81       	ldd	r25, Y+4	; 0x04
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
  24:	81 30       	cpi	r24, 0x01	; 1
  26:	91 05       	cpc	r25, r1
  28:	01 f0       	breq	.+0      	; 0x2a <GPIO_setupPortDirection+0x2a>
  2a:	2b 81       	ldd	r18, Y+3	; 0x03
  2c:	3c 81       	ldd	r19, Y+4	; 0x04
  2e:	22 30       	cpi	r18, 0x02	; 2
  30:	31 05       	cpc	r19, r1
  32:	04 f4       	brge	.+0      	; 0x34 <GPIO_setupPortDirection+0x34>
  34:	8b 81       	ldd	r24, Y+3	; 0x03
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f0       	breq	.+0      	; 0x3c <GPIO_setupPortDirection+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <GPIO_setupPortDirection+0x3e>
  3e:	2b 81       	ldd	r18, Y+3	; 0x03
  40:	3c 81       	ldd	r19, Y+4	; 0x04
  42:	22 30       	cpi	r18, 0x02	; 2
  44:	31 05       	cpc	r19, r1
  46:	01 f0       	breq	.+0      	; 0x48 <GPIO_setupPortDirection+0x48>
  48:	8b 81       	ldd	r24, Y+3	; 0x03
  4a:	9c 81       	ldd	r25, Y+4	; 0x04
  4c:	83 30       	cpi	r24, 0x03	; 3
  4e:	91 05       	cpc	r25, r1
  50:	01 f0       	breq	.+0      	; 0x52 <GPIO_setupPortDirection+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <GPIO_setupPortDirection+0x54>
  54:	ea e3       	ldi	r30, 0x3A	; 58
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	8a 81       	ldd	r24, Y+2	; 0x02
  5a:	80 83       	st	Z, r24
  5c:	00 c0       	rjmp	.+0      	; 0x5e <GPIO_setupPortDirection+0x5e>
  5e:	e7 e3       	ldi	r30, 0x37	; 55
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	8a 81       	ldd	r24, Y+2	; 0x02
  64:	80 83       	st	Z, r24
  66:	00 c0       	rjmp	.+0      	; 0x68 <GPIO_setupPortDirection+0x68>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
  68:	e4 e3       	ldi	r30, 0x34	; 52
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	8a 81       	ldd	r24, Y+2	; 0x02
			{
				SET_BIT(DDRA,pin_num);
  6e:	80 83       	st	Z, r24
  70:	00 c0       	rjmp	.+0      	; 0x72 <GPIO_setupPortDirection+0x72>
  72:	e1 e3       	ldi	r30, 0x31	; 49
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	8a 81       	ldd	r24, Y+2	; 0x02
  78:	80 83       	st	Z, r24
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	cf 91       	pop	r28
  84:	df 91       	pop	r29
  86:	08 95       	ret

Disassembly of section .text.GPIO_writePort:

00000000 <GPIO_writePort>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPIO_writePort+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <GPIO_writePort+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	84 30       	cpi	r24, 0x04	; 4
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
  14:	00 f4       	brcc	.+0      	; 0x16 <GPIO_writePort+0x16>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3c 83       	std	Y+4, r19	; 0x04
  1e:	2b 83       	std	Y+3, r18	; 0x03
  20:	8b 81       	ldd	r24, Y+3	; 0x03
  22:	9c 81       	ldd	r25, Y+4	; 0x04
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
  24:	81 30       	cpi	r24, 0x01	; 1
  26:	91 05       	cpc	r25, r1
  28:	01 f0       	breq	.+0      	; 0x2a <GPIO_writePort+0x2a>
  2a:	2b 81       	ldd	r18, Y+3	; 0x03
  2c:	3c 81       	ldd	r19, Y+4	; 0x04
  2e:	22 30       	cpi	r18, 0x02	; 2
  30:	31 05       	cpc	r19, r1
  32:	04 f4       	brge	.+0      	; 0x34 <GPIO_writePort+0x34>
  34:	8b 81       	ldd	r24, Y+3	; 0x03
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f0       	breq	.+0      	; 0x3c <GPIO_writePort+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <GPIO_writePort+0x3e>
  3e:	2b 81       	ldd	r18, Y+3	; 0x03
  40:	3c 81       	ldd	r19, Y+4	; 0x04
  42:	22 30       	cpi	r18, 0x02	; 2
  44:	31 05       	cpc	r19, r1
  46:	01 f0       	breq	.+0      	; 0x48 <GPIO_writePort+0x48>
  48:	8b 81       	ldd	r24, Y+3	; 0x03
  4a:	9c 81       	ldd	r25, Y+4	; 0x04
  4c:	83 30       	cpi	r24, 0x03	; 3
  4e:	91 05       	cpc	r25, r1
  50:	01 f0       	breq	.+0      	; 0x52 <GPIO_writePort+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <GPIO_writePort+0x54>
  54:	eb e3       	ldi	r30, 0x3B	; 59
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	8a 81       	ldd	r24, Y+2	; 0x02
  5a:	80 83       	st	Z, r24
  5c:	00 c0       	rjmp	.+0      	; 0x5e <GPIO_writePort+0x5e>
  5e:	e8 e3       	ldi	r30, 0x38	; 56
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	8a 81       	ldd	r24, Y+2	; 0x02
  64:	80 83       	st	Z, r24
  66:	00 c0       	rjmp	.+0      	; 0x68 <GPIO_writePort+0x68>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
  68:	e5 e3       	ldi	r30, 0x35	; 53
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	8a 81       	ldd	r24, Y+2	; 0x02
			{
				SET_BIT(DDRA,pin_num);
  6e:	80 83       	st	Z, r24
  70:	00 c0       	rjmp	.+0      	; 0x72 <GPIO_writePort+0x72>
  72:	e2 e3       	ldi	r30, 0x32	; 50
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	8a 81       	ldd	r24, Y+2	; 0x02
  78:	80 83       	st	Z, r24
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	cf 91       	pop	r28
  84:	df 91       	pop	r29
  86:	08 95       	ret

Disassembly of section .text.GPIO_readPort:

00000000 <GPIO_readPort>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <GPIO_readPort+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <GPIO_readPort+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	19 82       	std	Y+1, r1	; 0x01
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	84 30       	cpi	r24, 0x04	; 4
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
  14:	00 f4       	brcc	.+0      	; 0x16 <GPIO_readPort+0x16>
  16:	8a 81       	ldd	r24, Y+2	; 0x02
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3c 83       	std	Y+4, r19	; 0x04
  1e:	2b 83       	std	Y+3, r18	; 0x03
  20:	8b 81       	ldd	r24, Y+3	; 0x03
  22:	9c 81       	ldd	r25, Y+4	; 0x04
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
  24:	81 30       	cpi	r24, 0x01	; 1
  26:	91 05       	cpc	r25, r1
  28:	01 f0       	breq	.+0      	; 0x2a <GPIO_readPort+0x2a>
  2a:	2b 81       	ldd	r18, Y+3	; 0x03
  2c:	3c 81       	ldd	r19, Y+4	; 0x04
  2e:	22 30       	cpi	r18, 0x02	; 2
  30:	31 05       	cpc	r19, r1
  32:	04 f4       	brge	.+0      	; 0x34 <GPIO_readPort+0x34>
  34:	8b 81       	ldd	r24, Y+3	; 0x03
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	00 97       	sbiw	r24, 0x00	; 0
  3a:	01 f0       	breq	.+0      	; 0x3c <GPIO_readPort+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <GPIO_readPort+0x3e>
  3e:	2b 81       	ldd	r18, Y+3	; 0x03
  40:	3c 81       	ldd	r19, Y+4	; 0x04
  42:	22 30       	cpi	r18, 0x02	; 2
  44:	31 05       	cpc	r19, r1
  46:	01 f0       	breq	.+0      	; 0x48 <GPIO_readPort+0x48>
  48:	8b 81       	ldd	r24, Y+3	; 0x03
  4a:	9c 81       	ldd	r25, Y+4	; 0x04
  4c:	83 30       	cpi	r24, 0x03	; 3
  4e:	91 05       	cpc	r25, r1
  50:	01 f0       	breq	.+0      	; 0x52 <GPIO_readPort+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <GPIO_readPort+0x54>
  54:	e9 e3       	ldi	r30, 0x39	; 57
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	80 81       	ld	r24, Z
  5a:	89 83       	std	Y+1, r24	; 0x01
  5c:	00 c0       	rjmp	.+0      	; 0x5e <GPIO_readPort+0x5e>
  5e:	e6 e3       	ldi	r30, 0x36	; 54
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	80 81       	ld	r24, Z
  64:	89 83       	std	Y+1, r24	; 0x01
  66:	00 c0       	rjmp	.+0      	; 0x68 <GPIO_readPort+0x68>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
  68:	e3 e3       	ldi	r30, 0x33	; 51
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	80 81       	ld	r24, Z
			{
				SET_BIT(DDRA,pin_num);
  6e:	89 83       	std	Y+1, r24	; 0x01
  70:	00 c0       	rjmp	.+0      	; 0x72 <GPIO_readPort+0x72>
  72:	e0 e3       	ldi	r30, 0x30	; 48
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	80 81       	ld	r24, Z
  78:	89 83       	std	Y+1, r24	; 0x01
  7a:	89 81       	ldd	r24, Y+1	; 0x01
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	cf 91       	pop	r28
  86:	df 91       	pop	r29
  88:	08 95       	ret

icu.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005c4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000994  00000000  00000000  000005f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.g_callBackPtr 00000002  00000000  00000000  00000f8c  2**0
                  ALLOC
  6 .text.__vector_6 00000066  00000000  00000000  00000f8c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.ICU_init 00000092  00000000  00000000  00000ff2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.ICU_setCallBack 00000024  00000000  00000000  00001084  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.ICU_setEdgeDetectionType 0000003e  00000000  00000000  000010a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.ICU_getInputCaptureValue 00000016  00000000  00000000  000010e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.ICU_clearTimerValue 00000016  00000000  00000000  000010fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text.ICU_deInit 00000040  00000000  00000000  00001112  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.__vector_6:

00000000 <__vector_6>:
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_CAPT_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_6+0x36>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
	}
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.ICU_init:

00000000 <ICU_init>:
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <ICU_init+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	a1 e3       	ldi	r26, 0x31	; 49
  10:	b0 e0       	ldi	r27, 0x00	; 0
  12:	e1 e3       	ldi	r30, 0x31	; 49
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	8f 7b       	andi	r24, 0xBF	; 191
  1a:	8c 93       	st	X, r24
  1c:	ef e4       	ldi	r30, 0x4F	; 79
  1e:	f0 e0       	ldi	r31, 0x00	; 0
  20:	8c e0       	ldi	r24, 0x0C	; 12
  22:	80 83       	st	Z, r24
  24:	ae e4       	ldi	r26, 0x4E	; 78
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	ee e4       	ldi	r30, 0x4E	; 78
	if(g_callBackPtr != NULL_PTR)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	98 2f       	mov	r25, r24
  30:	98 7f       	andi	r25, 0xF8	; 248
  32:	e9 81       	ldd	r30, Y+1	; 0x01
  34:	fa 81       	ldd	r31, Y+2	; 0x02
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
  36:	80 81       	ld	r24, Z
  38:	89 2b       	or	r24, r25
  3a:	8c 93       	st	X, r24
  3c:	ae e4       	ldi	r26, 0x4E	; 78
  3e:	b0 e0       	ldi	r27, 0x00	; 0
	}
}
  40:	ee e4       	ldi	r30, 0x4E	; 78
  42:	f0 e0       	ldi	r31, 0x00	; 0
  44:	80 81       	ld	r24, Z
  46:	28 2f       	mov	r18, r24
  48:	2f 7b       	andi	r18, 0xBF	; 191
  4a:	e9 81       	ldd	r30, Y+1	; 0x01
  4c:	fa 81       	ldd	r31, Y+2	; 0x02
  4e:	81 81       	ldd	r24, Z+1	; 0x01
  50:	88 2f       	mov	r24, r24
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	00 24       	eor	r0, r0
  56:	96 95       	lsr	r25
  58:	87 95       	ror	r24
  5a:	07 94       	ror	r0
  5c:	96 95       	lsr	r25
  5e:	87 95       	ror	r24
  60:	07 94       	ror	r0
  62:	98 2f       	mov	r25, r24
  64:	80 2d       	mov	r24, r0
  66:	82 2b       	or	r24, r18
  68:	8c 93       	st	X, r24
  6a:	ec e4       	ldi	r30, 0x4C	; 76
  6c:	f0 e0       	ldi	r31, 0x00	; 0
  6e:	11 82       	std	Z+1, r1	; 0x01
  70:	10 82       	st	Z, r1
  72:	e6 e4       	ldi	r30, 0x46	; 70
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	11 82       	std	Z+1, r1	; 0x01
  78:	10 82       	st	Z, r1
  7a:	a9 e5       	ldi	r26, 0x59	; 89
  7c:	b0 e0       	ldi	r27, 0x00	; 0
  7e:	e9 e5       	ldi	r30, 0x59	; 89
  80:	f0 e0       	ldi	r31, 0x00	; 0
  82:	80 81       	ld	r24, Z
  84:	80 62       	ori	r24, 0x20	; 32
  86:	8c 93       	st	X, r24
  88:	0f 90       	pop	r0
  8a:	0f 90       	pop	r0
  8c:	cf 91       	pop	r28
  8e:	df 91       	pop	r29
  90:	08 95       	ret

Disassembly of section .text.ICU_setCallBack:

00000000 <ICU_setCallBack>:
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <ICU_setCallBack+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	9a 81       	ldd	r25, Y+2	; 0x02
  12:	90 93 00 00 	sts	0x0000, r25
  16:	80 93 00 00 	sts	0x0000, r24
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.ICU_setEdgeDetectionType:

00000000 <ICU_setEdgeDetectionType>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	ae e4       	ldi	r26, 0x4E	; 78
   e:	b0 e0       	ldi	r27, 0x00	; 0
  10:	ee e4       	ldi	r30, 0x4E	; 78
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	28 2f       	mov	r18, r24
  18:	2f 7b       	andi	r18, 0xBF	; 191
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	88 2f       	mov	r24, r24
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	00 24       	eor	r0, r0
  22:	96 95       	lsr	r25
  24:	87 95       	ror	r24
  26:	07 94       	ror	r0
  28:	96 95       	lsr	r25
	if(g_callBackPtr != NULL_PTR)
  2a:	87 95       	ror	r24
  2c:	07 94       	ror	r0
  2e:	98 2f       	mov	r25, r24
  30:	80 2d       	mov	r24, r0
  32:	82 2b       	or	r24, r18
  34:	8c 93       	st	X, r24
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
  36:	0f 90       	pop	r0
  38:	cf 91       	pop	r28
  3a:	df 91       	pop	r29
  3c:	08 95       	ret

Disassembly of section .text.ICU_getInputCaptureValue:

00000000 <ICU_getInputCaptureValue>:
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e6 e4       	ldi	r30, 0x46	; 70
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	91 81       	ldd	r25, Z+1	; 0x01
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
  14:	08 95       	ret

Disassembly of section .text.ICU_clearTimerValue:

00000000 <ICU_clearTimerValue>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ec e4       	ldi	r30, 0x4C	; 76
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	11 82       	std	Z+1, r1	; 0x01
   e:	10 82       	st	Z, r1
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
  14:	08 95       	ret

Disassembly of section .text.ICU_deInit:

00000000 <ICU_deInit>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ef e4       	ldi	r30, 0x4F	; 79
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	10 82       	st	Z, r1
   e:	ee e4       	ldi	r30, 0x4E	; 78
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	10 82       	st	Z, r1
  14:	ec e4       	ldi	r30, 0x4C	; 76
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	11 82       	std	Z+1, r1	; 0x01
  1a:	10 82       	st	Z, r1
  1c:	e6 e4       	ldi	r30, 0x46	; 70
  1e:	f0 e0       	ldi	r31, 0x00	; 0
  20:	11 82       	std	Z+1, r1	; 0x01
  22:	10 82       	st	Z, r1
  24:	a9 e5       	ldi	r26, 0x59	; 89
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	e9 e5       	ldi	r30, 0x59	; 89
	if(g_callBackPtr != NULL_PTR)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	8f 7d       	andi	r24, 0xDF	; 223
  30:	8c 93       	st	X, r24
  32:	10 92 00 00 	sts	0x0000, r1
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
  36:	10 92 00 00 	sts	0x0000, r1
  3a:	cf 91       	pop	r28
  3c:	df 91       	pop	r29
  3e:	08 95       	ret

pwm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000003d8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000007a4  00000000  00000000  0000040c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.PWM_Timer0_Start 00000064  00000000  00000000  00000bb0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.PWM_Timer0_Start:

00000000 <PWM_Timer0_Start>:

/*
 * Function to initialize Timer0 with Fast PWM mode.
 */
void PWM_Timer0_Start(uint8 duty_cycle)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = 0; 							/* Set Timer Initial value. */
   c:	e2 e5       	ldi	r30, 0x52	; 82
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	10 82       	st	Z, r1

	OCR0  = (duty_cycle * 255) / 100; 	/* Set Compare Value. */
  12:	ec e5       	ldi	r30, 0x5C	; 92
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	48 2f       	mov	r20, r24
  1a:	50 e0       	ldi	r21, 0x00	; 0
  1c:	ca 01       	movw	r24, r20
  1e:	9c 01       	movw	r18, r24
  20:	22 0f       	add	r18, r18
  22:	33 1f       	adc	r19, r19
  24:	c9 01       	movw	r24, r18
  26:	96 95       	lsr	r25
  28:	98 2f       	mov	r25, r24
  2a:	88 27       	eor	r24, r24
  2c:	97 95       	ror	r25
  2e:	87 95       	ror	r24
  30:	82 1b       	sub	r24, r18
  32:	93 0b       	sbc	r25, r19
  34:	84 0f       	add	r24, r20
  36:	95 1f       	adc	r25, r21
  38:	24 e6       	ldi	r18, 0x64	; 100
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	b9 01       	movw	r22, r18
  3e:	0e 94 00 00 	call	0	; 0x0 <PWM_Timer0_Start>
  42:	cb 01       	movw	r24, r22
  44:	80 83       	st	Z, r24

	DDRB  = DDRB | (1<<PB3); 			/* set PB3/OC0 as output pin --> pin where the PWM signal is generated from MC. */
  46:	a7 e3       	ldi	r26, 0x37	; 55
  48:	b0 e0       	ldi	r27, 0x00	; 0
  4a:	e7 e3       	ldi	r30, 0x37	; 55
  4c:	f0 e0       	ldi	r31, 0x00	; 0
  4e:	80 81       	ld	r24, Z
  50:	88 60       	ori	r24, 0x08	; 8
  52:	8c 93       	st	X, r24
	 * 1. Fast PWM mode FOC0=0
	 * 2. Fast PWM Mode WGM01=1 & WGM00=1
	 * 3. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
	 * 4. clock = F_CPU/64 CS00=1 CS00=0 CS02=1
	 */
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS00) | (1<<CS01);
  54:	e3 e5       	ldi	r30, 0x53	; 83
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	8b e6       	ldi	r24, 0x6B	; 107
  5a:	80 83       	st	Z, r24
}
  5c:	0f 90       	pop	r0
  5e:	cf 91       	pop	r28
  60:	df 91       	pop	r29
  62:	08 95       	ret

timer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000894  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000b3a  00000000  00000000  000008c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.g_callBackPtr_timer0 00000002  00000000  00000000  00001402  2**0
                  ALLOC
  6 .bss.g_callBackPtr_timer1 00000002  00000000  00000000  00001402  2**0
                  ALLOC
  7 .bss.g_callBackPtr_timer2 00000002  00000000  00000000  00001402  2**0
                  ALLOC
  8 .text.__vector_11 00000066  00000000  00000000  00001402  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.__vector_10 00000066  00000000  00000000  00001468  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.__vector_9 00000066  00000000  00000000  000014ce  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.__vector_7 00000066  00000000  00000000  00001534  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.__vector_5 00000066  00000000  00000000  0000159a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.__vector_4 00000066  00000000  00000000  00001600  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.Timer_init 000001c4  00000000  00000000  00001666  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.Timer_deInit 000000f4  00000000  00000000  0000182a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.Timer_getTimerValue 0000007c  00000000  00000000  0000191e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.Timer_setCallBack 00000072  00000000  00000000  0000199a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.__vector_11:

00000000 <__vector_11>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
	switch(timer_type)
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_11+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	}
}
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_10:

00000000 <__vector_10>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
	switch(timer_type)
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_10+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	}
}
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_9:

00000000 <__vector_9>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
	switch(timer_type)
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_9+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	}
}
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_7:

00000000 <__vector_7>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
	switch(timer_type)
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_7+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	}
}
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_5:

00000000 <__vector_5>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
	switch(timer_type)
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_5+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	}
}
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_4:

00000000 <__vector_4>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
	switch(timer_type)
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_4+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	}
}
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.Timer_init:

00000000 <Timer_init>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer_init+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <Timer_init+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	e9 81       	ldd	r30, Y+1	; 0x01
  12:	fa 81       	ldd	r31, Y+2	; 0x02
	switch(timer_type)
  14:	84 81       	ldd	r24, Z+4	; 0x04
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3c 83       	std	Y+4, r19	; 0x04
  1c:	2b 83       	std	Y+3, r18	; 0x03
  1e:	8b 81       	ldd	r24, Y+3	; 0x03
  20:	9c 81       	ldd	r25, Y+4	; 0x04
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	91 05       	cpc	r25, r1
  26:	01 f4       	brne	.+0      	; 0x28 <Timer_init+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <Timer_init+0x2a>
  2a:	2b 81       	ldd	r18, Y+3	; 0x03
  2c:	3c 81       	ldd	r19, Y+4	; 0x04
  2e:	22 30       	cpi	r18, 0x02	; 2
  30:	31 05       	cpc	r19, r1
  32:	01 f4       	brne	.+0      	; 0x34 <Timer_init+0x34>
  34:	00 c0       	rjmp	.+0      	; 0x36 <Timer_init+0x36>
  36:	8b 81       	ldd	r24, Y+3	; 0x03
  38:	9c 81       	ldd	r25, Y+4	; 0x04
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	00 97       	sbiw	r24, 0x00	; 0
  3c:	01 f0       	breq	.+0      	; 0x3e <Timer_init+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <Timer_init+0x40>
  40:	a3 e5       	ldi	r26, 0x53	; 83
  42:	b0 e0       	ldi	r27, 0x00	; 0
  44:	e9 81       	ldd	r30, Y+1	; 0x01
  46:	fa 81       	ldd	r31, Y+2	; 0x02
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	86 81       	ldd	r24, Z+6	; 0x06
  4a:	88 2f       	mov	r24, r24
  4c:	90 e0       	ldi	r25, 0x00	; 0
  4e:	88 0f       	add	r24, r24
  50:	99 1f       	adc	r25, r25
  52:	88 0f       	add	r24, r24
  54:	99 1f       	adc	r25, r25
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	88 0f       	add	r24, r24
  58:	99 1f       	adc	r25, r25
  5a:	98 2f       	mov	r25, r24
  5c:	90 68       	ori	r25, 0x80	; 128
  5e:	e9 81       	ldd	r30, Y+1	; 0x01
  60:	fa 81       	ldd	r31, Y+2	; 0x02
		break;
	}
}
  62:	85 81       	ldd	r24, Z+5	; 0x05
  64:	89 2b       	or	r24, r25
  66:	8c 93       	st	X, r24
  68:	a2 e5       	ldi	r26, 0x52	; 82
  6a:	b0 e0       	ldi	r27, 0x00	; 0
  6c:	e9 81       	ldd	r30, Y+1	; 0x01
  6e:	fa 81       	ldd	r31, Y+2	; 0x02
  70:	80 81       	ld	r24, Z
  72:	91 81       	ldd	r25, Z+1	; 0x01
  74:	8c 93       	st	X, r24
  76:	e9 81       	ldd	r30, Y+1	; 0x01
  78:	fa 81       	ldd	r31, Y+2	; 0x02
  7a:	86 81       	ldd	r24, Z+6	; 0x06
  7c:	81 30       	cpi	r24, 0x01	; 1
  7e:	01 f4       	brne	.+0      	; 0x80 <Timer_init+0x80>
  80:	ac e5       	ldi	r26, 0x5C	; 92
  82:	b0 e0       	ldi	r27, 0x00	; 0
  84:	e9 81       	ldd	r30, Y+1	; 0x01
  86:	fa 81       	ldd	r31, Y+2	; 0x02
  88:	82 81       	ldd	r24, Z+2	; 0x02
  8a:	93 81       	ldd	r25, Z+3	; 0x03
  8c:	8c 93       	st	X, r24
  8e:	e9 81       	ldd	r30, Y+1	; 0x01
  90:	fa 81       	ldd	r31, Y+2	; 0x02
  92:	86 81       	ldd	r24, Z+6	; 0x06
  94:	88 23       	and	r24, r24
  96:	01 f4       	brne	.+0      	; 0x98 <Timer_init+0x98>
  98:	a9 e5       	ldi	r26, 0x59	; 89
  9a:	b0 e0       	ldi	r27, 0x00	; 0
  9c:	e9 e5       	ldi	r30, 0x59	; 89
  9e:	f0 e0       	ldi	r31, 0x00	; 0
  a0:	80 81       	ld	r24, Z
  a2:	81 60       	ori	r24, 0x01	; 1
  a4:	8c 93       	st	X, r24
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <Timer_init+0xa8>
  a8:	a9 e5       	ldi	r26, 0x59	; 89
  aa:	b0 e0       	ldi	r27, 0x00	; 0
  ac:	e9 e5       	ldi	r30, 0x59	; 89
  ae:	f0 e0       	ldi	r31, 0x00	; 0
  b0:	80 81       	ld	r24, Z
  b2:	82 60       	ori	r24, 0x02	; 2
  b4:	8c 93       	st	X, r24
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <Timer_init+0xb8>
  b8:	ef e4       	ldi	r30, 0x4F	; 79
  ba:	f0 e0       	ldi	r31, 0x00	; 0
  bc:	8c e0       	ldi	r24, 0x0C	; 12
  be:	80 83       	st	Z, r24
  c0:	ae e4       	ldi	r26, 0x4E	; 78
  c2:	b0 e0       	ldi	r27, 0x00	; 0
  c4:	e9 81       	ldd	r30, Y+1	; 0x01
  c6:	fa 81       	ldd	r31, Y+2	; 0x02
  c8:	86 81       	ldd	r24, Z+6	; 0x06
  ca:	88 2f       	mov	r24, r24
  cc:	90 e0       	ldi	r25, 0x00	; 0
  ce:	88 0f       	add	r24, r24
  d0:	99 1f       	adc	r25, r25
  d2:	88 0f       	add	r24, r24
  d4:	99 1f       	adc	r25, r25
  d6:	88 0f       	add	r24, r24
  d8:	99 1f       	adc	r25, r25
  da:	98 2f       	mov	r25, r24
  dc:	e9 81       	ldd	r30, Y+1	; 0x01
  de:	fa 81       	ldd	r31, Y+2	; 0x02
  e0:	85 81       	ldd	r24, Z+5	; 0x05
  e2:	89 2b       	or	r24, r25
  e4:	8c 93       	st	X, r24
  e6:	ac e4       	ldi	r26, 0x4C	; 76
  e8:	b0 e0       	ldi	r27, 0x00	; 0
  ea:	e9 81       	ldd	r30, Y+1	; 0x01
  ec:	fa 81       	ldd	r31, Y+2	; 0x02
  ee:	80 81       	ld	r24, Z
  f0:	91 81       	ldd	r25, Z+1	; 0x01
  f2:	11 96       	adiw	r26, 0x01	; 1
  f4:	9c 93       	st	X, r25
  f6:	8e 93       	st	-X, r24
  f8:	e9 81       	ldd	r30, Y+1	; 0x01
  fa:	fa 81       	ldd	r31, Y+2	; 0x02
  fc:	86 81       	ldd	r24, Z+6	; 0x06
  fe:	81 30       	cpi	r24, 0x01	; 1
 100:	01 f4       	brne	.+0      	; 0x102 <Timer_init+0x102>
 102:	ea e4       	ldi	r30, 0x4A	; 74
 104:	f0 e0       	ldi	r31, 0x00	; 0
 106:	a9 81       	ldd	r26, Y+1	; 0x01
 108:	ba 81       	ldd	r27, Y+2	; 0x02
 10a:	12 96       	adiw	r26, 0x02	; 2
 10c:	8d 91       	ld	r24, X+
 10e:	9c 91       	ld	r25, X
 110:	13 97       	sbiw	r26, 0x03	; 3
 112:	91 83       	std	Z+1, r25	; 0x01
 114:	80 83       	st	Z, r24
 116:	e9 81       	ldd	r30, Y+1	; 0x01
 118:	fa 81       	ldd	r31, Y+2	; 0x02
 11a:	86 81       	ldd	r24, Z+6	; 0x06
 11c:	88 23       	and	r24, r24
 11e:	01 f4       	brne	.+0      	; 0x120 <Timer_init+0x120>
 120:	a9 e5       	ldi	r26, 0x59	; 89
 122:	b0 e0       	ldi	r27, 0x00	; 0
 124:	e9 e5       	ldi	r30, 0x59	; 89
 126:	f0 e0       	ldi	r31, 0x00	; 0
 128:	80 81       	ld	r24, Z
 12a:	84 60       	ori	r24, 0x04	; 4
 12c:	8c 93       	st	X, r24
 12e:	00 c0       	rjmp	.+0      	; 0x130 <Timer_init+0x130>
 130:	a9 e5       	ldi	r26, 0x59	; 89
 132:	b0 e0       	ldi	r27, 0x00	; 0
 134:	e9 e5       	ldi	r30, 0x59	; 89
 136:	f0 e0       	ldi	r31, 0x00	; 0
 138:	80 81       	ld	r24, Z
 13a:	80 61       	ori	r24, 0x10	; 16
 13c:	8c 93       	st	X, r24
 13e:	00 c0       	rjmp	.+0      	; 0x140 <Timer_init+0x140>
 140:	a5 e4       	ldi	r26, 0x45	; 69
 142:	b0 e0       	ldi	r27, 0x00	; 0
 144:	e9 81       	ldd	r30, Y+1	; 0x01
 146:	fa 81       	ldd	r31, Y+2	; 0x02
 148:	86 81       	ldd	r24, Z+6	; 0x06
 14a:	88 2f       	mov	r24, r24
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	88 0f       	add	r24, r24
 150:	99 1f       	adc	r25, r25
 152:	88 0f       	add	r24, r24
 154:	99 1f       	adc	r25, r25
 156:	88 0f       	add	r24, r24
 158:	99 1f       	adc	r25, r25
 15a:	98 2f       	mov	r25, r24
 15c:	90 68       	ori	r25, 0x80	; 128
 15e:	e9 81       	ldd	r30, Y+1	; 0x01
 160:	fa 81       	ldd	r31, Y+2	; 0x02
 162:	85 81       	ldd	r24, Z+5	; 0x05
 164:	89 2b       	or	r24, r25
 166:	8c 93       	st	X, r24
 168:	a4 e4       	ldi	r26, 0x44	; 68
 16a:	b0 e0       	ldi	r27, 0x00	; 0
 16c:	e9 81       	ldd	r30, Y+1	; 0x01
 16e:	fa 81       	ldd	r31, Y+2	; 0x02
 170:	80 81       	ld	r24, Z
 172:	91 81       	ldd	r25, Z+1	; 0x01
 174:	8c 93       	st	X, r24
 176:	e9 81       	ldd	r30, Y+1	; 0x01
 178:	fa 81       	ldd	r31, Y+2	; 0x02
 17a:	86 81       	ldd	r24, Z+6	; 0x06
 17c:	81 30       	cpi	r24, 0x01	; 1
 17e:	01 f4       	brne	.+0      	; 0x180 <Timer_init+0x180>
 180:	a3 e4       	ldi	r26, 0x43	; 67
 182:	b0 e0       	ldi	r27, 0x00	; 0
 184:	e9 81       	ldd	r30, Y+1	; 0x01
 186:	fa 81       	ldd	r31, Y+2	; 0x02
 188:	82 81       	ldd	r24, Z+2	; 0x02
 18a:	93 81       	ldd	r25, Z+3	; 0x03
 18c:	8c 93       	st	X, r24
 18e:	e9 81       	ldd	r30, Y+1	; 0x01
 190:	fa 81       	ldd	r31, Y+2	; 0x02
 192:	86 81       	ldd	r24, Z+6	; 0x06
 194:	88 23       	and	r24, r24
 196:	01 f4       	brne	.+0      	; 0x198 <Timer_init+0x198>
 198:	a9 e5       	ldi	r26, 0x59	; 89
 19a:	b0 e0       	ldi	r27, 0x00	; 0
 19c:	e9 e5       	ldi	r30, 0x59	; 89
 19e:	f0 e0       	ldi	r31, 0x00	; 0
 1a0:	80 81       	ld	r24, Z
 1a2:	80 64       	ori	r24, 0x40	; 64
 1a4:	8c 93       	st	X, r24
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <Timer_init+0x1a8>
 1a8:	a9 e5       	ldi	r26, 0x59	; 89
 1aa:	b0 e0       	ldi	r27, 0x00	; 0
 1ac:	e9 e5       	ldi	r30, 0x59	; 89
 1ae:	f0 e0       	ldi	r31, 0x00	; 0
 1b0:	80 81       	ld	r24, Z
 1b2:	80 68       	ori	r24, 0x80	; 128
 1b4:	8c 93       	st	X, r24
 1b6:	0f 90       	pop	r0
 1b8:	0f 90       	pop	r0
 1ba:	0f 90       	pop	r0
 1bc:	0f 90       	pop	r0
 1be:	cf 91       	pop	r28
 1c0:	df 91       	pop	r29
 1c2:	08 95       	ret

Disassembly of section .text.Timer_deInit:

00000000 <Timer_deInit>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer_deInit+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
	switch(timer_type)
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <Timer_deInit+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f4       	brne	.+0      	; 0x2c <Timer_deInit+0x2c>
  2c:	00 c0       	rjmp	.+0      	; 0x2e <Timer_deInit+0x2e>
  2e:	8a 81       	ldd	r24, Y+2	; 0x02
  30:	9b 81       	ldd	r25, Y+3	; 0x03
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <Timer_deInit+0x36>
  36:	00 c0       	rjmp	.+0      	; 0x38 <Timer_deInit+0x38>
  38:	e3 e5       	ldi	r30, 0x53	; 83
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	f0 e0       	ldi	r31, 0x00	; 0
  3c:	10 82       	st	Z, r1
  3e:	e2 e5       	ldi	r30, 0x52	; 82
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	10 82       	st	Z, r1
  44:	ec e5       	ldi	r30, 0x5C	; 92
  46:	f0 e0       	ldi	r31, 0x00	; 0
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	10 82       	st	Z, r1
  4a:	a9 e5       	ldi	r26, 0x59	; 89
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	e9 e5       	ldi	r30, 0x59	; 89
  50:	f0 e0       	ldi	r31, 0x00	; 0
  52:	80 81       	ld	r24, Z
  54:	8e 7f       	andi	r24, 0xFE	; 254
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	8c 93       	st	X, r24
  58:	a9 e5       	ldi	r26, 0x59	; 89
  5a:	b0 e0       	ldi	r27, 0x00	; 0
  5c:	e9 e5       	ldi	r30, 0x59	; 89
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	80 81       	ld	r24, Z
		break;
	}
}
  62:	8d 7f       	andi	r24, 0xFD	; 253
  64:	8c 93       	st	X, r24
  66:	10 92 00 00 	sts	0x0000, r1
  6a:	10 92 00 00 	sts	0x0000, r1
  6e:	00 c0       	rjmp	.+0      	; 0x70 <Timer_deInit+0x70>
  70:	ef e4       	ldi	r30, 0x4F	; 79
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	10 82       	st	Z, r1
  76:	ee e4       	ldi	r30, 0x4E	; 78
  78:	f0 e0       	ldi	r31, 0x00	; 0
  7a:	10 82       	st	Z, r1
  7c:	ec e4       	ldi	r30, 0x4C	; 76
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	11 82       	std	Z+1, r1	; 0x01
  82:	10 82       	st	Z, r1
  84:	ea e4       	ldi	r30, 0x4A	; 74
  86:	f0 e0       	ldi	r31, 0x00	; 0
  88:	11 82       	std	Z+1, r1	; 0x01
  8a:	10 82       	st	Z, r1
  8c:	a9 e5       	ldi	r26, 0x59	; 89
  8e:	b0 e0       	ldi	r27, 0x00	; 0
  90:	e9 e5       	ldi	r30, 0x59	; 89
  92:	f0 e0       	ldi	r31, 0x00	; 0
  94:	80 81       	ld	r24, Z
  96:	8b 7f       	andi	r24, 0xFB	; 251
  98:	8c 93       	st	X, r24
  9a:	a9 e5       	ldi	r26, 0x59	; 89
  9c:	b0 e0       	ldi	r27, 0x00	; 0
  9e:	e9 e5       	ldi	r30, 0x59	; 89
  a0:	f0 e0       	ldi	r31, 0x00	; 0
  a2:	80 81       	ld	r24, Z
  a4:	8f 7e       	andi	r24, 0xEF	; 239
  a6:	8c 93       	st	X, r24
  a8:	10 92 00 00 	sts	0x0000, r1
  ac:	10 92 00 00 	sts	0x0000, r1
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <Timer_deInit+0xb2>
  b2:	e5 e4       	ldi	r30, 0x45	; 69
  b4:	f0 e0       	ldi	r31, 0x00	; 0
  b6:	10 82       	st	Z, r1
  b8:	e4 e4       	ldi	r30, 0x44	; 68
  ba:	f0 e0       	ldi	r31, 0x00	; 0
  bc:	10 82       	st	Z, r1
  be:	e3 e4       	ldi	r30, 0x43	; 67
  c0:	f0 e0       	ldi	r31, 0x00	; 0
  c2:	10 82       	st	Z, r1
  c4:	a9 e5       	ldi	r26, 0x59	; 89
  c6:	b0 e0       	ldi	r27, 0x00	; 0
  c8:	e9 e5       	ldi	r30, 0x59	; 89
  ca:	f0 e0       	ldi	r31, 0x00	; 0
  cc:	80 81       	ld	r24, Z
  ce:	8f 7b       	andi	r24, 0xBF	; 191
  d0:	8c 93       	st	X, r24
  d2:	a9 e5       	ldi	r26, 0x59	; 89
  d4:	b0 e0       	ldi	r27, 0x00	; 0
  d6:	e9 e5       	ldi	r30, 0x59	; 89
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	80 81       	ld	r24, Z
  dc:	8f 77       	andi	r24, 0x7F	; 127
  de:	8c 93       	st	X, r24
  e0:	10 92 00 00 	sts	0x0000, r1
  e4:	10 92 00 00 	sts	0x0000, r1
  e8:	0f 90       	pop	r0
  ea:	0f 90       	pop	r0
  ec:	0f 90       	pop	r0
  ee:	cf 91       	pop	r28
  f0:	df 91       	pop	r29
  f2:	08 95       	ret

Disassembly of section .text.Timer_getTimerValue:

00000000 <Timer_getTimerValue>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer_getTimerValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <Timer_getTimerValue+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	28 2f       	mov	r18, r24
	switch(timer_type)
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3d 83       	std	Y+5, r19	; 0x05
  18:	2c 83       	std	Y+4, r18	; 0x04
  1a:	8c 81       	ldd	r24, Y+4	; 0x04
  1c:	9d 81       	ldd	r25, Y+5	; 0x05
  1e:	81 30       	cpi	r24, 0x01	; 1
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <Timer_getTimerValue+0x24>
  24:	2c 81       	ldd	r18, Y+4	; 0x04
  26:	3d 81       	ldd	r19, Y+5	; 0x05
  28:	22 30       	cpi	r18, 0x02	; 2
  2a:	31 05       	cpc	r19, r1
  2c:	01 f0       	breq	.+0      	; 0x2e <Timer_getTimerValue+0x2e>
  2e:	8c 81       	ldd	r24, Y+4	; 0x04
  30:	9d 81       	ldd	r25, Y+5	; 0x05
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f4       	brne	.+0      	; 0x36 <Timer_getTimerValue+0x36>
  36:	e2 e5       	ldi	r30, 0x52	; 82
  38:	f0 e0       	ldi	r31, 0x00	; 0
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	80 81       	ld	r24, Z
  3c:	28 2f       	mov	r18, r24
  3e:	30 e0       	ldi	r19, 0x00	; 0
  40:	3b 83       	std	Y+3, r19	; 0x03
  42:	2a 83       	std	Y+2, r18	; 0x02
  44:	00 c0       	rjmp	.+0      	; 0x46 <Timer_getTimerValue+0x46>
  46:	ec e4       	ldi	r30, 0x4C	; 76
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	f0 e0       	ldi	r31, 0x00	; 0
  4a:	80 81       	ld	r24, Z
  4c:	91 81       	ldd	r25, Z+1	; 0x01
  4e:	9b 83       	std	Y+3, r25	; 0x03
  50:	8a 83       	std	Y+2, r24	; 0x02
  52:	00 c0       	rjmp	.+0      	; 0x54 <Timer_getTimerValue+0x54>
  54:	e4 e4       	ldi	r30, 0x44	; 68
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	80 81       	ld	r24, Z
  5a:	28 2f       	mov	r18, r24
  5c:	30 e0       	ldi	r19, 0x00	; 0
  5e:	3b 83       	std	Y+3, r19	; 0x03
  60:	2a 83       	std	Y+2, r18	; 0x02
		break;
	}
}
  62:	00 c0       	rjmp	.+0      	; 0x64 <Timer_getTimerValue+0x64>
  64:	1b 82       	std	Y+3, r1	; 0x03
  66:	1a 82       	std	Y+2, r1	; 0x02
  68:	8a 81       	ldd	r24, Y+2	; 0x02
  6a:	9b 81       	ldd	r25, Y+3	; 0x03
  6c:	0f 90       	pop	r0
  6e:	0f 90       	pop	r0
  70:	0f 90       	pop	r0
  72:	0f 90       	pop	r0
  74:	0f 90       	pop	r0
  76:	cf 91       	pop	r28
  78:	df 91       	pop	r29
  7a:	08 95       	ret

Disassembly of section .text.Timer_setCallBack:

00000000 <Timer_setCallBack>:

/*
 * Function to set the Call Back function address to the required Timer.
 */
void Timer_setCallBack(void(*a_ptr)(void), Timer_ID_Type timer_type)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Timer_setCallBack+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <Timer_setCallBack+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9a 83       	std	Y+2, r25	; 0x02
  10:	89 83       	std	Y+1, r24	; 0x01
  12:	6b 83       	std	Y+3, r22	; 0x03
	switch(timer_type)
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3d 83       	std	Y+5, r19	; 0x05
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <Timer_setCallBack+0x28>
  28:	2c 81       	ldd	r18, Y+4	; 0x04
  2a:	3d 81       	ldd	r19, Y+5	; 0x05
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	01 f0       	breq	.+0      	; 0x32 <Timer_setCallBack+0x32>
  32:	8c 81       	ldd	r24, Y+4	; 0x04
  34:	9d 81       	ldd	r25, Y+5	; 0x05
  36:	00 97       	sbiw	r24, 0x00	; 0
  38:	01 f4       	brne	.+0      	; 0x3a <Timer_setCallBack+0x3a>
	{
	case TIMER0_ID:
		g_callBackPtr_timer0 = a_ptr;
  3a:	89 81       	ldd	r24, Y+1	; 0x01
  3c:	9a 81       	ldd	r25, Y+2	; 0x02
  3e:	90 93 00 00 	sts	0x0000, r25
  42:	80 93 00 00 	sts	0x0000, r24
  46:	00 c0       	rjmp	.+0      	; 0x48 <Timer_setCallBack+0x48>
		break;
	case TIMER1_ID:
		g_callBackPtr_timer1 = a_ptr;
  48:	89 81       	ldd	r24, Y+1	; 0x01
  4a:	9a 81       	ldd	r25, Y+2	; 0x02
  4c:	90 93 00 00 	sts	0x0000, r25
  50:	80 93 00 00 	sts	0x0000, r24
  54:	00 c0       	rjmp	.+0      	; 0x56 <Timer_setCallBack+0x56>
		break;
	case TIMER2_ID:
		g_callBackPtr_timer2 = a_ptr;
  56:	89 81       	ldd	r24, Y+1	; 0x01
  58:	9a 81       	ldd	r25, Y+2	; 0x02
  5a:	90 93 00 00 	sts	0x0000, r25
  5e:	80 93 00 00 	sts	0x0000, r24
		break;
	}
}
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
  6a:	0f 90       	pop	r0
  6c:	cf 91       	pop	r28
  6e:	df 91       	pop	r29
  70:	08 95       	ret

twi.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005ac  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000008c4  00000000  00000000  000005e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.TWI_init 0000003e  00000000  00000000  00000ea4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.TWI_start 00000020  00000000  00000000  00000ee2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.TWI_stop 00000016  00000000  00000000  00000f02  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.TWI_writeByte 0000002e  00000000  00000000  00000f18  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.TWI_readByteWithACK 00000026  00000000  00000000  00000f46  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.TWI_readByteWithNACK 00000026  00000000  00000000  00000f6c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.TWI_getStatus 0000001e  00000000  00000000  00000f92  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.TWI_init:

00000000 <TWI_init>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <TWI_init+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	a0 e2       	ldi	r26, 0x20	; 32
  10:	b0 e0       	ldi	r27, 0x00	; 0
  12:	e9 81       	ldd	r30, Y+1	; 0x01
  14:	fa 81       	ldd	r31, Y+2	; 0x02
  16:	81 81       	ldd	r24, Z+1	; 0x01
  18:	8c 93       	st	X, r24
	TWSR = 0x00;
  1a:	e1 e2       	ldi	r30, 0x21	; 33
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	10 82       	st	Z, r1
	
    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    TWAR = Config_Ptr->address; 	/* my address. */
  20:	a2 e2       	ldi	r26, 0x22	; 34
  22:	b0 e0       	ldi	r27, 0x00	; 0
  24:	e9 81       	ldd	r30, Y+1	; 0x01
  26:	fa 81       	ldd	r31, Y+2	; 0x02
  28:	80 81       	ld	r24, Z
  2a:	8c 93       	st	X, r24
	
    TWCR = (1<<TWEN); /* enable TWI */
  2c:	e6 e5       	ldi	r30, 0x56	; 86
  2e:	f0 e0       	ldi	r31, 0x00	; 0
  30:	84 e0       	ldi	r24, 0x04	; 4
  32:	80 83       	st	Z, r24
}
  34:	0f 90       	pop	r0
  36:	0f 90       	pop	r0
  38:	cf 91       	pop	r28
  3a:	df 91       	pop	r29
  3c:	08 95       	ret

Disassembly of section .text.TWI_start:

00000000 <TWI_start>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e6 e5       	ldi	r30, 0x56	; 86
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	84 ea       	ldi	r24, 0xA4	; 164
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	80 83       	st	Z, r24
  10:	e6 e5       	ldi	r30, 0x56	; 86
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	88 23       	and	r24, r24
  18:	04 f4       	brge	.+0      	; 0x1a <TWI_start+0x1a>
	TWSR = 0x00;
  1a:	cf 91       	pop	r28
  1c:	df 91       	pop	r29
  1e:	08 95       	ret

Disassembly of section .text.TWI_stop:

00000000 <TWI_stop>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e6 e5       	ldi	r30, 0x56	; 86
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	84 e9       	ldi	r24, 0x94	; 148
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	80 83       	st	Z, r24
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
  14:	08 95       	ret

Disassembly of section .text.TWI_writeByte:

00000000 <TWI_writeByte>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	e3 e2       	ldi	r30, 0x23	; 35
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	80 83       	st	Z, r24
  14:	e6 e5       	ldi	r30, 0x56	; 86
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	84 e8       	ldi	r24, 0x84	; 132
	TWSR = 0x00;
  1a:	80 83       	st	Z, r24
  1c:	e6 e5       	ldi	r30, 0x56	; 86
  1e:	f0 e0       	ldi	r31, 0x00	; 0
	
    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    TWAR = Config_Ptr->address; 	/* my address. */
  20:	80 81       	ld	r24, Z
  22:	88 23       	and	r24, r24
  24:	04 f4       	brge	.+0      	; 0x26 <TWI_writeByte+0x26>
  26:	0f 90       	pop	r0
  28:	cf 91       	pop	r28
  2a:	df 91       	pop	r29
	
    TWCR = (1<<TWEN); /* enable TWI */
  2c:	08 95       	ret

Disassembly of section .text.TWI_readByteWithACK:

00000000 <TWI_readByteWithACK>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e6 e5       	ldi	r30, 0x56	; 86
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	84 ec       	ldi	r24, 0xC4	; 196
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	80 83       	st	Z, r24
  10:	e6 e5       	ldi	r30, 0x56	; 86
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	88 23       	and	r24, r24
  18:	04 f4       	brge	.+0      	; 0x1a <TWI_readByteWithACK+0x1a>
	TWSR = 0x00;
  1a:	e3 e2       	ldi	r30, 0x23	; 35
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
	
    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    TWAR = Config_Ptr->address; 	/* my address. */
  20:	cf 91       	pop	r28
  22:	df 91       	pop	r29
  24:	08 95       	ret

Disassembly of section .text.TWI_readByteWithNACK:

00000000 <TWI_readByteWithNACK>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e6 e5       	ldi	r30, 0x56	; 86
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	84 e8       	ldi	r24, 0x84	; 132
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	80 83       	st	Z, r24
  10:	e6 e5       	ldi	r30, 0x56	; 86
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	88 23       	and	r24, r24
  18:	04 f4       	brge	.+0      	; 0x1a <TWI_readByteWithNACK+0x1a>
	TWSR = 0x00;
  1a:	e3 e2       	ldi	r30, 0x23	; 35
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
	
    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    TWAR = Config_Ptr->address; 	/* my address. */
  20:	cf 91       	pop	r28
  22:	df 91       	pop	r29
  24:	08 95       	ret

Disassembly of section .text.TWI_getStatus:

00000000 <TWI_getStatus>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	e1 e2       	ldi	r30, 0x21	; 33
   c:	f0 e0       	ldi	r31, 0x00	; 0
    /*
     * Bit Rate.
	 * Pre-scaler.
	 */
    TWBR = Config_Ptr->bit_rate;
   e:	80 81       	ld	r24, Z
  10:	88 7f       	andi	r24, 0xF8	; 248
  12:	89 83       	std	Y+1, r24	; 0x01
  14:	89 81       	ldd	r24, Y+1	; 0x01
  16:	0f 90       	pop	r0
  18:	cf 91       	pop	r28
	TWSR = 0x00;
  1a:	df 91       	pop	r29
  1c:	08 95       	ret

uart.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000738  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000a63  00000000  00000000  0000076c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.UART_init 000000d2  00000000  00000000  000011cf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.UART_sendByte 0000002e  00000000  00000000  000012a1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.UART_receiveByte 0000001e  00000000  00000000  000012cf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.UART_sendString 00000052  00000000  00000000  000012ed  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.UART_receiveString 00000086  00000000  00000000  0000133f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.UART_sendArray 0000004e  00000000  00000000  000013c5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.UART_receiveArray 00000074  00000000  00000000  00001413  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.UART_init:

00000000 <UART_init>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <UART_init+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <UART_init+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9c 83       	std	Y+4, r25	; 0x04
   e:	8b 83       	std	Y+3, r24	; 0x03
    uint16 ubrr_value = 0;
  10:	1a 82       	std	Y+2, r1	; 0x02
  12:	19 82       	std	Y+1, r1	; 0x01

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	eb e2       	ldi	r30, 0x2B	; 43
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	82 e0       	ldi	r24, 0x02	; 2
  1a:	80 83       	st	Z, r24
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	ea e2       	ldi	r30, 0x2A	; 42
  1e:	f0 e0       	ldi	r31, 0x00	; 0
  20:	88 e1       	ldi	r24, 0x18	; 24
  22:	80 83       	st	Z, r24
     * UPM1:0  = 00 Disable parity bit, 10  Even Parity, 11  Odd Parity
     * USBS    = 0 One stop bit, 1 Two stop bit
     * UCSZ1:0 = 11 For 8-bit data mode
     * UCPOL   = 0 Used with the Synchronous operation only
     ***********************************************************************/
    UCSRC = (1<<URSEL) | ((Config_Ptr->bit_data)<<UCSZ0) |
  24:	a0 e4       	ldi	r26, 0x40	; 64
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	eb 81       	ldd	r30, Y+3	; 0x03
  2a:	fc 81       	ldd	r31, Y+4	; 0x04
  2c:	86 81       	ldd	r24, Z+6	; 0x06
  2e:	88 2f       	mov	r24, r24
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	88 0f       	add	r24, r24
  34:	99 1f       	adc	r25, r25
  36:	28 2f       	mov	r18, r24
  38:	20 68       	ori	r18, 0x80	; 128
  3a:	eb 81       	ldd	r30, Y+3	; 0x03
  3c:	fc 81       	ldd	r31, Y+4	; 0x04
  3e:	84 81       	ldd	r24, Z+4	; 0x04
  40:	88 2f       	mov	r24, r24
  42:	90 e0       	ldi	r25, 0x00	; 0
  44:	82 95       	swap	r24
  46:	92 95       	swap	r25
  48:	90 7f       	andi	r25, 0xF0	; 240
  4a:	98 27       	eor	r25, r24
  4c:	80 7f       	andi	r24, 0xF0	; 240
  4e:	98 27       	eor	r25, r24
  50:	28 2b       	or	r18, r24
  52:	eb 81       	ldd	r30, Y+3	; 0x03
  54:	fc 81       	ldd	r31, Y+4	; 0x04
  56:	85 81       	ldd	r24, Z+5	; 0x05
  58:	88 2f       	mov	r24, r24
  5a:	90 e0       	ldi	r25, 0x00	; 0
  5c:	88 0f       	add	r24, r24
  5e:	99 1f       	adc	r25, r25
  60:	88 0f       	add	r24, r24
  62:	99 1f       	adc	r25, r25
  64:	88 0f       	add	r24, r24
  66:	99 1f       	adc	r25, r25
  68:	82 2b       	or	r24, r18
  6a:	8c 93       	st	X, r24
            ((Config_Ptr->Parity_Configurations)<<UPM0) |
            ((Config_Ptr->StopBit_Configurations)<<USBS);

    /* Calculate the UBRR register value */
    ubrr_value = (uint16)(((F_CPU / (Config_Ptr->baudRate * 8UL))) - 1);
  6c:	eb 81       	ldd	r30, Y+3	; 0x03
  6e:	fc 81       	ldd	r31, Y+4	; 0x04
  70:	80 81       	ld	r24, Z
  72:	91 81       	ldd	r25, Z+1	; 0x01
  74:	a2 81       	ldd	r26, Z+2	; 0x02
  76:	b3 81       	ldd	r27, Z+3	; 0x03
  78:	88 0f       	add	r24, r24
  7a:	99 1f       	adc	r25, r25
  7c:	aa 1f       	adc	r26, r26
  7e:	bb 1f       	adc	r27, r27
  80:	88 0f       	add	r24, r24
  82:	99 1f       	adc	r25, r25
  84:	aa 1f       	adc	r26, r26
  86:	bb 1f       	adc	r27, r27
  88:	88 0f       	add	r24, r24
  8a:	99 1f       	adc	r25, r25
  8c:	aa 1f       	adc	r26, r26
  8e:	bb 1f       	adc	r27, r27
  90:	9c 01       	movw	r18, r24
  92:	ad 01       	movw	r20, r26
  94:	80 e0       	ldi	r24, 0x00	; 0
  96:	94 e2       	ldi	r25, 0x24	; 36
  98:	a4 ef       	ldi	r26, 0xF4	; 244
  9a:	b0 e0       	ldi	r27, 0x00	; 0
  9c:	bc 01       	movw	r22, r24
  9e:	cd 01       	movw	r24, r26
  a0:	0e 94 00 00 	call	0	; 0x0 <UART_init>
  a4:	da 01       	movw	r26, r20
  a6:	c9 01       	movw	r24, r18
  a8:	01 97       	sbiw	r24, 0x01	; 1
  aa:	9a 83       	std	Y+2, r25	; 0x02
  ac:	89 83       	std	Y+1, r24	; 0x01

    /* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH */
    UBRRH = ubrr_value>>8;
  ae:	e0 e4       	ldi	r30, 0x40	; 64
  b0:	f0 e0       	ldi	r31, 0x00	; 0
  b2:	89 81       	ldd	r24, Y+1	; 0x01
  b4:	9a 81       	ldd	r25, Y+2	; 0x02
  b6:	89 2f       	mov	r24, r25
  b8:	99 27       	eor	r25, r25
  ba:	80 83       	st	Z, r24
    UBRRL = ubrr_value;
  bc:	e9 e2       	ldi	r30, 0x29	; 41
  be:	f0 e0       	ldi	r31, 0x00	; 0
  c0:	89 81       	ldd	r24, Y+1	; 0x01
  c2:	80 83       	st	Z, r24
}
  c4:	0f 90       	pop	r0
  c6:	0f 90       	pop	r0
  c8:	0f 90       	pop	r0
  ca:	0f 90       	pop	r0
  cc:	cf 91       	pop	r28
  ce:	df 91       	pop	r29
  d0:	08 95       	ret

Disassembly of section .text.UART_sendByte:

00000000 <UART_sendByte>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	eb e2       	ldi	r30, 0x2B	; 43
   e:	f0 e0       	ldi	r31, 0x00	; 0
    uint16 ubrr_value = 0;
  10:	80 81       	ld	r24, Z
  12:	88 2f       	mov	r24, r24

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	90 e0       	ldi	r25, 0x00	; 0
  16:	80 72       	andi	r24, 0x20	; 32
  18:	90 70       	andi	r25, 0x00	; 0
  1a:	00 97       	sbiw	r24, 0x00	; 0
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	01 f0       	breq	.+0      	; 0x1e <UART_sendByte+0x1e>
  1e:	ec e2       	ldi	r30, 0x2C	; 44
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	89 81       	ldd	r24, Y+1	; 0x01
     * UPM1:0  = 00 Disable parity bit, 10  Even Parity, 11  Odd Parity
     * USBS    = 0 One stop bit, 1 Two stop bit
     * UCSZ1:0 = 11 For 8-bit data mode
     * UCPOL   = 0 Used with the Synchronous operation only
     ***********************************************************************/
    UCSRC = (1<<URSEL) | ((Config_Ptr->bit_data)<<UCSZ0) |
  24:	80 83       	st	Z, r24
  26:	0f 90       	pop	r0
  28:	cf 91       	pop	r28
  2a:	df 91       	pop	r29
  2c:	08 95       	ret

Disassembly of section .text.UART_receiveByte:

00000000 <UART_receiveByte>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	eb e2       	ldi	r30, 0x2B	; 43
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	88 23       	and	r24, r24
    uint16 ubrr_value = 0;
  10:	04 f4       	brge	.+0      	; 0x12 <UART_receiveByte+0x12>
  12:	ec e2       	ldi	r30, 0x2C	; 44

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	cf 91       	pop	r28
  1a:	df 91       	pop	r29
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	08 95       	ret

Disassembly of section .text.UART_sendString:

00000000 <UART_sendString>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <UART_sendString+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
    uint16 ubrr_value = 0;
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	00 c0       	rjmp	.+0      	; 0x14 <UART_sendString+0x14>

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	89 81       	ldd	r24, Y+1	; 0x01
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	fc 01       	movw	r30, r24
  20:	e2 0f       	add	r30, r18
  22:	f3 1f       	adc	r31, r19
     * UPM1:0  = 00 Disable parity bit, 10  Even Parity, 11  Odd Parity
     * USBS    = 0 One stop bit, 1 Two stop bit
     * UCSZ1:0 = 11 For 8-bit data mode
     * UCPOL   = 0 Used with the Synchronous operation only
     ***********************************************************************/
    UCSRC = (1<<URSEL) | ((Config_Ptr->bit_data)<<UCSZ0) |
  24:	80 81       	ld	r24, Z
  26:	0e 94 00 00 	call	0	; 0x0 <UART_sendString>
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	8f 5f       	subi	r24, 0xFF	; 255
  2e:	89 83       	std	Y+1, r24	; 0x01
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	28 2f       	mov	r18, r24
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	8a 81       	ldd	r24, Y+2	; 0x02
  38:	9b 81       	ldd	r25, Y+3	; 0x03
  3a:	fc 01       	movw	r30, r24
  3c:	e2 0f       	add	r30, r18
  3e:	f3 1f       	adc	r31, r19
  40:	80 81       	ld	r24, Z
  42:	88 23       	and	r24, r24
  44:	01 f4       	brne	.+0      	; 0x46 <UART_sendString+0x46>
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	cf 91       	pop	r28
  4e:	df 91       	pop	r29
  50:	08 95       	ret

Disassembly of section .text.UART_receiveString:

00000000 <UART_receiveString>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	00 d0       	rcall	.+0      	; 0xa <UART_receiveString+0xa>
   a:	0f 92       	push	r0
   c:	cd b7       	in	r28, 0x3d	; 61
   e:	de b7       	in	r29, 0x3e	; 62
    uint16 ubrr_value = 0;
  10:	9b 83       	std	Y+3, r25	; 0x03
  12:	8a 83       	std	Y+2, r24	; 0x02

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	19 82       	std	Y+1, r1	; 0x01
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	9b 81       	ldd	r25, Y+3	; 0x03
  20:	8c 01       	movw	r16, r24
  22:	02 0f       	add	r16, r18
     * UPM1:0  = 00 Disable parity bit, 10  Even Parity, 11  Odd Parity
     * USBS    = 0 One stop bit, 1 Two stop bit
     * UCSZ1:0 = 11 For 8-bit data mode
     * UCPOL   = 0 Used with the Synchronous operation only
     ***********************************************************************/
    UCSRC = (1<<URSEL) | ((Config_Ptr->bit_data)<<UCSZ0) |
  24:	13 1f       	adc	r17, r19
  26:	0e 94 00 00 	call	0	; 0x0 <UART_receiveString>
  2a:	f8 01       	movw	r30, r16
  2c:	80 83       	st	Z, r24
  2e:	00 c0       	rjmp	.+0      	; 0x30 <UART_receiveString+0x30>
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	8f 5f       	subi	r24, 0xFF	; 255
  34:	89 83       	std	Y+1, r24	; 0x01
  36:	89 81       	ldd	r24, Y+1	; 0x01
  38:	28 2f       	mov	r18, r24
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	8a 81       	ldd	r24, Y+2	; 0x02
  3e:	9b 81       	ldd	r25, Y+3	; 0x03
  40:	8c 01       	movw	r16, r24
  42:	02 0f       	add	r16, r18
  44:	13 1f       	adc	r17, r19
  46:	0e 94 00 00 	call	0	; 0x0 <UART_receiveString>
  4a:	f8 01       	movw	r30, r16
  4c:	80 83       	st	Z, r24
  4e:	89 81       	ldd	r24, Y+1	; 0x01
  50:	28 2f       	mov	r18, r24
  52:	30 e0       	ldi	r19, 0x00	; 0
  54:	8a 81       	ldd	r24, Y+2	; 0x02
  56:	9b 81       	ldd	r25, Y+3	; 0x03
  58:	fc 01       	movw	r30, r24
  5a:	e2 0f       	add	r30, r18
  5c:	f3 1f       	adc	r31, r19
  5e:	80 81       	ld	r24, Z
  60:	83 32       	cpi	r24, 0x23	; 35
  62:	01 f4       	brne	.+0      	; 0x64 <UART_receiveString+0x64>
  64:	89 81       	ldd	r24, Y+1	; 0x01
  66:	28 2f       	mov	r18, r24
  68:	30 e0       	ldi	r19, 0x00	; 0
  6a:	8a 81       	ldd	r24, Y+2	; 0x02
            ((Config_Ptr->Parity_Configurations)<<UPM0) |
            ((Config_Ptr->StopBit_Configurations)<<USBS);

    /* Calculate the UBRR register value */
    ubrr_value = (uint16)(((F_CPU / (Config_Ptr->baudRate * 8UL))) - 1);
  6c:	9b 81       	ldd	r25, Y+3	; 0x03
  6e:	fc 01       	movw	r30, r24
  70:	e2 0f       	add	r30, r18
  72:	f3 1f       	adc	r31, r19
  74:	10 82       	st	Z, r1
  76:	0f 90       	pop	r0
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	cf 91       	pop	r28
  7e:	df 91       	pop	r29
  80:	1f 91       	pop	r17
  82:	0f 91       	pop	r16
  84:	08 95       	ret

Disassembly of section .text.UART_sendArray:

00000000 <UART_sendArray>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <UART_sendArray+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <UART_sendArray+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
    uint16 ubrr_value = 0;
  10:	6c 83       	std	Y+4, r22	; 0x04
  12:	19 82       	std	Y+1, r1	; 0x01

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	00 c0       	rjmp	.+0      	; 0x16 <UART_sendArray+0x16>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	9b 81       	ldd	r25, Y+3	; 0x03
  20:	fc 01       	movw	r30, r24
  22:	e2 0f       	add	r30, r18
     * UPM1:0  = 00 Disable parity bit, 10  Even Parity, 11  Odd Parity
     * USBS    = 0 One stop bit, 1 Two stop bit
     * UCSZ1:0 = 11 For 8-bit data mode
     * UCPOL   = 0 Used with the Synchronous operation only
     ***********************************************************************/
    UCSRC = (1<<URSEL) | ((Config_Ptr->bit_data)<<UCSZ0) |
  24:	f3 1f       	adc	r31, r19
  26:	80 81       	ld	r24, Z
  28:	0e 94 00 00 	call	0	; 0x0 <UART_sendArray>
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	8f 5f       	subi	r24, 0xFF	; 255
  30:	89 83       	std	Y+1, r24	; 0x01
  32:	99 81       	ldd	r25, Y+1	; 0x01
  34:	8c 81       	ldd	r24, Y+4	; 0x04
  36:	98 17       	cp	r25, r24
  38:	00 f0       	brcs	.+0      	; 0x3a <UART_sendArray+0x3a>
  3a:	83 e2       	ldi	r24, 0x23	; 35
  3c:	0e 94 00 00 	call	0	; 0x0 <UART_sendArray>
  40:	0f 90       	pop	r0
  42:	0f 90       	pop	r0
  44:	0f 90       	pop	r0
  46:	0f 90       	pop	r0
  48:	cf 91       	pop	r28
  4a:	df 91       	pop	r29
  4c:	08 95       	ret

Disassembly of section .text.UART_receiveArray:

00000000 <UART_receiveArray>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	00 d0       	rcall	.+0      	; 0xa <UART_receiveArray+0xa>
   a:	0f 92       	push	r0
   c:	cd b7       	in	r28, 0x3d	; 61
   e:	de b7       	in	r29, 0x3e	; 62
    uint16 ubrr_value = 0;
  10:	9b 83       	std	Y+3, r25	; 0x03
  12:	8a 83       	std	Y+2, r24	; 0x02

    /* U2X = 1 for double transmission speed */
    UCSRA = (1<<U2X);
  14:	19 82       	std	Y+1, r1	; 0x01
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
     * RXEN  = 1 Receiver Enable
     * RXEN  = 1 Transmitter Enable
     * UCSZ2 = 0 For 5-bit, 6-bit, 7-bit, 8-bit data mode
     * RXB8 & TXB8 not used for 8-bit data mode
     ***********************************************************************/
    UCSRB = (1<<RXEN) | (1<<TXEN);
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	9b 81       	ldd	r25, Y+3	; 0x03
  20:	8c 01       	movw	r16, r24
  22:	02 0f       	add	r16, r18
     * UPM1:0  = 00 Disable parity bit, 10  Even Parity, 11  Odd Parity
     * USBS    = 0 One stop bit, 1 Two stop bit
     * UCSZ1:0 = 11 For 8-bit data mode
     * UCPOL   = 0 Used with the Synchronous operation only
     ***********************************************************************/
    UCSRC = (1<<URSEL) | ((Config_Ptr->bit_data)<<UCSZ0) |
  24:	13 1f       	adc	r17, r19
  26:	0e 94 00 00 	call	0	; 0x0 <UART_receiveArray>
  2a:	f8 01       	movw	r30, r16
  2c:	80 83       	st	Z, r24
  2e:	00 c0       	rjmp	.+0      	; 0x30 <UART_receiveArray+0x30>
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	8f 5f       	subi	r24, 0xFF	; 255
  34:	89 83       	std	Y+1, r24	; 0x01
  36:	89 81       	ldd	r24, Y+1	; 0x01
  38:	28 2f       	mov	r18, r24
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	8a 81       	ldd	r24, Y+2	; 0x02
  3e:	9b 81       	ldd	r25, Y+3	; 0x03
  40:	8c 01       	movw	r16, r24
  42:	02 0f       	add	r16, r18
  44:	13 1f       	adc	r17, r19
  46:	0e 94 00 00 	call	0	; 0x0 <UART_receiveArray>
  4a:	f8 01       	movw	r30, r16
  4c:	80 83       	st	Z, r24
  4e:	89 81       	ldd	r24, Y+1	; 0x01
  50:	28 2f       	mov	r18, r24
  52:	30 e0       	ldi	r19, 0x00	; 0
  54:	8a 81       	ldd	r24, Y+2	; 0x02
  56:	9b 81       	ldd	r25, Y+3	; 0x03
  58:	fc 01       	movw	r30, r24
  5a:	e2 0f       	add	r30, r18
  5c:	f3 1f       	adc	r31, r19
  5e:	80 81       	ld	r24, Z
  60:	83 32       	cpi	r24, 0x23	; 35
  62:	01 f4       	brne	.+0      	; 0x64 <UART_receiveArray+0x64>
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
  6a:	cf 91       	pop	r28
            ((Config_Ptr->Parity_Configurations)<<UPM0) |
            ((Config_Ptr->StopBit_Configurations)<<USBS);

    /* Calculate the UBRR register value */
    ubrr_value = (uint16)(((F_CPU / (Config_Ptr->baudRate * 8UL))) - 1);
  6c:	df 91       	pop	r29
  6e:	1f 91       	pop	r17
  70:	0f 91       	pop	r16
  72:	08 95       	ret

buzzer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000258  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000410  00000000  00000000  0000028c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.Buzzer_init 00000022  00000000  00000000  0000069c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.Buzzer_on 00000018  00000000  00000000  000006be  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.Buzzer_off 00000018  00000000  00000000  000006d6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.Buzzer_init:

00000000 <Buzzer_init>:

/*
 * Initializes the buzzer pin direction and turn off the buzzer.
 */
void Buzzer_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT_CONNECTION, BUZZER_PIN_CONNECION, PIN_OUTPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	67 e0       	ldi	r22, 0x07	; 7
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <Buzzer_init>
	GPIO_writePin(BUZZER_PORT_CONNECTION, BUZZER_PIN_CONNECION, LOGIC_LOW);
  12:	82 e0       	ldi	r24, 0x02	; 2
  14:	67 e0       	ldi	r22, 0x07	; 7
  16:	40 e0       	ldi	r20, 0x00	; 0
  18:	0e 94 00 00 	call	0	; 0x0 <Buzzer_init>
}
  1c:	cf 91       	pop	r28
  1e:	df 91       	pop	r29
  20:	08 95       	ret

Disassembly of section .text.Buzzer_on:

00000000 <Buzzer_on>:

/*
 * Initializes the buzzer pin direction and turn off the buzzer.
 */
void Buzzer_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT_CONNECTION, BUZZER_PIN_CONNECION, PIN_OUTPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	67 e0       	ldi	r22, 0x07	; 7
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <Buzzer_on>
	GPIO_writePin(BUZZER_PORT_CONNECTION, BUZZER_PIN_CONNECION, LOGIC_LOW);
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.Buzzer_off:

00000000 <Buzzer_off>:

/*
 * Initializes the buzzer pin direction and turn off the buzzer.
 */
void Buzzer_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT_CONNECTION, BUZZER_PIN_CONNECION, PIN_OUTPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	67 e0       	ldi	r22, 0x07	; 7
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <Buzzer_off>
	GPIO_writePin(BUZZER_PORT_CONNECTION, BUZZER_PIN_CONNECION, LOGIC_LOW);
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

external_eeprom.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000003d8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000457  00000000  00000000  0000040c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.EEPROM_writeByte 00000082  00000000  00000000  00000863  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.EEPROM_readByte 000000c0  00000000  00000000  000008e5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.EEPROM_writeByte:

00000000 <EEPROM_writeByte>:

/*
 * Function to write byte using I2C (TWI).
 */
uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EEPROM_writeByte+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <EEPROM_writeByte+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
  12:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
    if (TWI_getStatus() != TWI_START)
  16:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
  1a:	88 30       	cpi	r24, 0x08	; 8
  1c:	01 f0       	breq	.+0      	; 0x1e <EEPROM_writeByte+0x1e>
        return ERROR;
  1e:	1c 82       	std	Y+4, r1	; 0x04
  20:	00 c0       	rjmp	.+0      	; 0x22 <EEPROM_writeByte+0x22>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	9a 81       	ldd	r25, Y+2	; 0x02
  26:	80 70       	andi	r24, 0x00	; 0
  28:	97 70       	andi	r25, 0x07	; 7
  2a:	88 0f       	add	r24, r24
  2c:	89 2f       	mov	r24, r25
  2e:	88 1f       	adc	r24, r24
  30:	99 0b       	sbc	r25, r25
  32:	91 95       	neg	r25
  34:	80 6a       	ori	r24, 0xA0	; 160
  36:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
  3a:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
  3e:	88 31       	cpi	r24, 0x18	; 24
  40:	01 f0       	breq	.+0      	; 0x42 <EEPROM_writeByte+0x42>
        return ERROR; 
  42:	1c 82       	std	Y+4, r1	; 0x04
  44:	00 c0       	rjmp	.+0      	; 0x46 <EEPROM_writeByte+0x46>
		 
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
  46:	89 81       	ldd	r24, Y+1	; 0x01
  48:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
  4c:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
  50:	88 32       	cpi	r24, 0x28	; 40
  52:	01 f0       	breq	.+0      	; 0x54 <EEPROM_writeByte+0x54>
        return ERROR;
  54:	1c 82       	std	Y+4, r1	; 0x04
  56:	00 c0       	rjmp	.+0      	; 0x58 <EEPROM_writeByte+0x58>
		
    /* write byte to eeprom */
    TWI_writeByte(u8data);
  58:	8b 81       	ldd	r24, Y+3	; 0x03
  5a:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
  5e:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
  62:	88 32       	cpi	r24, 0x28	; 40
  64:	01 f0       	breq	.+0      	; 0x66 <EEPROM_writeByte+0x66>
        return ERROR;
  66:	1c 82       	std	Y+4, r1	; 0x04
  68:	00 c0       	rjmp	.+0      	; 0x6a <EEPROM_writeByte+0x6a>

    /* Send the Stop Bit */
    TWI_stop();
  6a:	0e 94 00 00 	call	0	; 0x0 <EEPROM_writeByte>
	
    return SUCCESS;
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	8c 83       	std	Y+4, r24	; 0x04
  72:	8c 81       	ldd	r24, Y+4	; 0x04
}
  74:	0f 90       	pop	r0
  76:	0f 90       	pop	r0
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	cf 91       	pop	r28
  7e:	df 91       	pop	r29
  80:	08 95       	ret

Disassembly of section .text.EEPROM_readByte:

00000000 <EEPROM_readByte>:

/*
 * Function to write byte using I2C (TWI).
 */
uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <EEPROM_readByte+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <EEPROM_readByte+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9a 83       	std	Y+2, r25	; 0x02
  10:	89 83       	std	Y+1, r24	; 0x01
	/* Send the Start Bit */
    TWI_start();
  12:	7c 83       	std	Y+4, r23	; 0x04
  14:	6b 83       	std	Y+3, r22	; 0x03
    if (TWI_getStatus() != TWI_START)
  16:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  1a:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
        return ERROR;
  1e:	88 30       	cpi	r24, 0x08	; 8
  20:	01 f0       	breq	.+0      	; 0x22 <EEPROM_readByte+0x22>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
  22:	1d 82       	std	Y+5, r1	; 0x05
  24:	00 c0       	rjmp	.+0      	; 0x26 <EEPROM_readByte+0x26>
  26:	89 81       	ldd	r24, Y+1	; 0x01
  28:	9a 81       	ldd	r25, Y+2	; 0x02
  2a:	80 70       	andi	r24, 0x00	; 0
  2c:	97 70       	andi	r25, 0x07	; 7
  2e:	88 0f       	add	r24, r24
  30:	89 2f       	mov	r24, r25
  32:	88 1f       	adc	r24, r24
  34:	99 0b       	sbc	r25, r25
  36:	91 95       	neg	r25
  38:	80 6a       	ori	r24, 0xA0	; 160
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
  3a:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  3e:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
        return ERROR; 
  42:	88 31       	cpi	r24, 0x18	; 24
  44:	01 f0       	breq	.+0      	; 0x46 <EEPROM_readByte+0x46>
		 
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
  46:	1d 82       	std	Y+5, r1	; 0x05
  48:	00 c0       	rjmp	.+0      	; 0x4a <EEPROM_readByte+0x4a>
  4a:	89 81       	ldd	r24, Y+1	; 0x01
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
  4c:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  50:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
        return ERROR;
  54:	88 32       	cpi	r24, 0x28	; 40
  56:	01 f0       	breq	.+0      	; 0x58 <EEPROM_readByte+0x58>
		
    /* write byte to eeprom */
    TWI_writeByte(u8data);
  58:	1d 82       	std	Y+5, r1	; 0x05
  5a:	00 c0       	rjmp	.+0      	; 0x5c <EEPROM_readByte+0x5c>
  5c:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
  60:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  64:	80 31       	cpi	r24, 0x10	; 16
        return ERROR;
  66:	01 f0       	breq	.+0      	; 0x68 <EEPROM_readByte+0x68>
  68:	1d 82       	std	Y+5, r1	; 0x05

    /* Send the Stop Bit */
    TWI_stop();
  6a:	00 c0       	rjmp	.+0      	; 0x6c <EEPROM_readByte+0x6c>
  6c:	89 81       	ldd	r24, Y+1	; 0x01
	
    return SUCCESS;
  6e:	9a 81       	ldd	r25, Y+2	; 0x02
  70:	80 70       	andi	r24, 0x00	; 0
  72:	97 70       	andi	r25, 0x07	; 7
}
  74:	88 0f       	add	r24, r24
  76:	89 2f       	mov	r24, r25
  78:	88 1f       	adc	r24, r24
  7a:	99 0b       	sbc	r25, r25
  7c:	91 95       	neg	r25
  7e:	81 6a       	ori	r24, 0xA1	; 161
  80:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  84:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  88:	80 34       	cpi	r24, 0x40	; 64
  8a:	01 f0       	breq	.+0      	; 0x8c <EEPROM_readByte+0x8c>
  8c:	1d 82       	std	Y+5, r1	; 0x05
  8e:	00 c0       	rjmp	.+0      	; 0x90 <EEPROM_readByte+0x90>
  90:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  94:	eb 81       	ldd	r30, Y+3	; 0x03
  96:	fc 81       	ldd	r31, Y+4	; 0x04
  98:	80 83       	st	Z, r24
  9a:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  9e:	88 35       	cpi	r24, 0x58	; 88
  a0:	01 f0       	breq	.+0      	; 0xa2 <EEPROM_readByte+0xa2>
  a2:	1d 82       	std	Y+5, r1	; 0x05
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <EEPROM_readByte+0xa6>
  a6:	0e 94 00 00 	call	0	; 0x0 <EEPROM_readByte>
  aa:	81 e0       	ldi	r24, 0x01	; 1
  ac:	8d 83       	std	Y+5, r24	; 0x05
  ae:	8d 81       	ldd	r24, Y+5	; 0x05
  b0:	0f 90       	pop	r0
  b2:	0f 90       	pop	r0
  b4:	0f 90       	pop	r0
  b6:	0f 90       	pop	r0
  b8:	0f 90       	pop	r0
  ba:	cf 91       	pop	r28
  bc:	df 91       	pop	r29
  be:	08 95       	ret

flame_sensor.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000234  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000426  00000000  00000000  00000268  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.FlameSensor_init 00000018  00000000  00000000  0000068e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.FlameSensor_getValue 00000016  00000000  00000000  000006a6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.FlameSensor_init:

00000000 <FlameSensor_init>:

/*
 * Initializes the flame sensor.
 */
void FlameSensor_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(FLAME_PORT_CONNECTION, FLAME_PIN_CONNECTION, PIN_INPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	62 e0       	ldi	r22, 0x02	; 2
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <FlameSensor_init>
}
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.FlameSensor_getValue:

00000000 <FlameSensor_getValue>:

/*
 * Initializes the flame sensor.
 */
void FlameSensor_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(FLAME_PORT_CONNECTION, FLAME_PIN_CONNECTION, PIN_INPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	62 e0       	ldi	r22, 0x02	; 2
   c:	0e 94 00 00 	call	0	; 0x0 <FlameSensor_getValue>
  10:	cf 91       	pop	r28
}
  12:	df 91       	pop	r29
  14:	08 95       	ret

keypad.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000069c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000900  00000000  00000000  000006d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.KEYPAD_getPressedKey 000001c8  00000000  00000000  00000fd0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.KEYPAD_4x4_adjustKeyNumber 0000014e  00000000  00000000  00001198  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.KEYPAD_getPressedKey:

00000000 <KEYPAD_getPressedKey>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/

uint8 KEYPAD_getPressedKey(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	60 97       	sbiw	r28, 0x10	; 16
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
	uint8 col,row;
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID, PIN_INPUT);
  14:	81 e0       	ldi	r24, 0x01	; 1
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	40 e0       	ldi	r20, 0x00	; 0
  1a:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+1, PIN_INPUT);
  1e:	81 e0       	ldi	r24, 0x01	; 1
  20:	61 e0       	ldi	r22, 0x01	; 1
  22:	40 e0       	ldi	r20, 0x00	; 0
  24:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+2, PIN_INPUT);
  28:	81 e0       	ldi	r24, 0x01	; 1
  2a:	62 e0       	ldi	r22, 0x02	; 2
  2c:	40 e0       	ldi	r20, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+3, PIN_INPUT);
  32:	81 e0       	ldi	r24, 0x01	; 1
  34:	63 e0       	ldi	r22, 0x03	; 3
  36:	40 e0       	ldi	r20, 0x00	; 0
  38:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>

	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID, PIN_INPUT);
  3c:	81 e0       	ldi	r24, 0x01	; 1
  3e:	64 e0       	ldi	r22, 0x04	; 4
  40:	40 e0       	ldi	r20, 0x00	; 0
  42:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+1, PIN_INPUT);
  46:	81 e0       	ldi	r24, 0x01	; 1
  48:	65 e0       	ldi	r22, 0x05	; 5
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+2, PIN_INPUT);
  50:	81 e0       	ldi	r24, 0x01	; 1
  52:	66 e0       	ldi	r22, 0x06	; 6
  54:	40 e0       	ldi	r20, 0x00	; 0
  56:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
#if(4 == KEYPAD_NUM_COLS)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
  5a:	81 e0       	ldi	r24, 0x01	; 1
  5c:	67 e0       	ldi	r22, 0x07	; 7
  5e:	40 e0       	ldi	r20, 0x00	; 0
  60:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
  64:	1f 86       	std	Y+15, r1	; 0x0f
  66:	00 c0       	rjmp	.+0      	; 0x68 <KEYPAD_getPressedKey+0x68>
		{
			/* 
			 * Each time setup the direction for all keypad port as input pins,
			 * except this row will be output pin
			 */
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);
  68:	81 e0       	ldi	r24, 0x01	; 1
  6a:	6f 85       	ldd	r22, Y+15	; 0x0f
  6c:	41 e0       	ldi	r20, 0x01	; 1
  6e:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);
  72:	81 e0       	ldi	r24, 0x01	; 1
  74:	6f 85       	ldd	r22, Y+15	; 0x0f
  76:	40 e0       	ldi	r20, 0x00	; 0
  78:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
  7c:	18 8a       	std	Y+16, r1	; 0x10
  7e:	00 c0       	rjmp	.+0      	; 0x80 <KEYPAD_getPressedKey+0x80>
			{
				/* Check if the switch is pressed in this column */
				if(GPIO_readPin(KEYPAD_COL_PORT_ID,KEYPAD_FIRST_COL_PIN_ID+col) == KEYPAD_BUTTON_PRESSED)
  80:	88 89       	ldd	r24, Y+16	; 0x10
  82:	98 2f       	mov	r25, r24
  84:	9c 5f       	subi	r25, 0xFC	; 252
  86:	81 e0       	ldi	r24, 0x01	; 1
  88:	69 2f       	mov	r22, r25
  8a:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
  8e:	88 23       	and	r24, r24
  90:	01 f4       	brne	.+0      	; 0x92 <KEYPAD_getPressedKey+0x92>
						#endif
					#elif (KEYPAD_NUM_COLS == 4)
						#ifdef STANDARD_KEYPAD
							return ((row*KEYPAD_NUM_COLS)+col+1);
						#else
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
  92:	8f 85       	ldd	r24, Y+15	; 0x0f
  94:	88 2f       	mov	r24, r24
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	88 0f       	add	r24, r24
  9a:	99 1f       	adc	r25, r25
  9c:	88 0f       	add	r24, r24
  9e:	99 1f       	adc	r25, r25
  a0:	98 2f       	mov	r25, r24
  a2:	88 89       	ldd	r24, Y+16	; 0x10
  a4:	89 0f       	add	r24, r25
  a6:	8f 5f       	subi	r24, 0xFF	; 255
  a8:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
			_delay_ms(5); /* Add small delay to fix CPU load issue in proteus */
		}
	}	
}
  ac:	60 96       	adiw	r28, 0x10	; 16
  ae:	0f b6       	in	r0, 0x3f	; 63
  b0:	f8 94       	cli
  b2:	de bf       	out	0x3e, r29	; 62
  b4:	0f be       	out	0x3f, r0	; 63
  b6:	cd bf       	out	0x3d, r28	; 61
  b8:	cf 91       	pop	r28
  ba:	df 91       	pop	r29
  bc:	08 95       	ret
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
  be:	88 89       	ldd	r24, Y+16	; 0x10
  c0:	8f 5f       	subi	r24, 0xFF	; 255
  c2:	88 8b       	std	Y+16, r24	; 0x10
  c4:	88 89       	ldd	r24, Y+16	; 0x10
  c6:	84 30       	cpi	r24, 0x04	; 4
  c8:	00 f0       	brcs	.+0      	; 0xca <KEYPAD_getPressedKey+0xca>
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
						#endif
					#endif
				}
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
  ca:	81 e0       	ldi	r24, 0x01	; 1
  cc:	6f 85       	ldd	r22, Y+15	; 0x0f
  ce:	40 e0       	ldi	r20, 0x00	; 0
  d0:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
  d4:	80 e0       	ldi	r24, 0x00	; 0
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	a0 ea       	ldi	r26, 0xA0	; 160
  da:	b0 e4       	ldi	r27, 0x40	; 64
  dc:	8b 87       	std	Y+11, r24	; 0x0b
  de:	9c 87       	std	Y+12, r25	; 0x0c
  e0:	ad 87       	std	Y+13, r26	; 0x0d
  e2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  e4:	6b 85       	ldd	r22, Y+11	; 0x0b
  e6:	7c 85       	ldd	r23, Y+12	; 0x0c
  e8:	8d 85       	ldd	r24, Y+13	; 0x0d
  ea:	9e 85       	ldd	r25, Y+14	; 0x0e
  ec:	20 e0       	ldi	r18, 0x00	; 0
  ee:	30 e0       	ldi	r19, 0x00	; 0
  f0:	4a e7       	ldi	r20, 0x7A	; 122
  f2:	55 e4       	ldi	r21, 0x45	; 69
  f4:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
  f8:	dc 01       	movw	r26, r24
  fa:	cb 01       	movw	r24, r22
  fc:	8f 83       	std	Y+7, r24	; 0x07
  fe:	98 87       	std	Y+8, r25	; 0x08
 100:	a9 87       	std	Y+9, r26	; 0x09
 102:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
 104:	6f 81       	ldd	r22, Y+7	; 0x07
 106:	78 85       	ldd	r23, Y+8	; 0x08
 108:	89 85       	ldd	r24, Y+9	; 0x09
 10a:	9a 85       	ldd	r25, Y+10	; 0x0a
 10c:	20 e0       	ldi	r18, 0x00	; 0
 10e:	30 e0       	ldi	r19, 0x00	; 0
 110:	40 e8       	ldi	r20, 0x80	; 128
 112:	5f e3       	ldi	r21, 0x3F	; 63
 114:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
 118:	88 23       	and	r24, r24
 11a:	04 f4       	brge	.+0      	; 0x11c <KEYPAD_getPressedKey+0x11c>
		__ticks = 1;
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	9e 83       	std	Y+6, r25	; 0x06
 122:	8d 83       	std	Y+5, r24	; 0x05
 124:	00 c0       	rjmp	.+0      	; 0x126 <KEYPAD_getPressedKey+0x126>
	else if (__tmp > 65535)
 126:	6f 81       	ldd	r22, Y+7	; 0x07
 128:	78 85       	ldd	r23, Y+8	; 0x08
 12a:	89 85       	ldd	r24, Y+9	; 0x09
 12c:	9a 85       	ldd	r25, Y+10	; 0x0a
 12e:	20 e0       	ldi	r18, 0x00	; 0
 130:	3f ef       	ldi	r19, 0xFF	; 255
 132:	4f e7       	ldi	r20, 0x7F	; 127
 134:	57 e4       	ldi	r21, 0x47	; 71
 136:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
 13a:	18 16       	cp	r1, r24
 13c:	04 f4       	brge	.+0      	; 0x13e <KEYPAD_getPressedKey+0x13e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 13e:	6b 85       	ldd	r22, Y+11	; 0x0b
 140:	7c 85       	ldd	r23, Y+12	; 0x0c
 142:	8d 85       	ldd	r24, Y+13	; 0x0d
 144:	9e 85       	ldd	r25, Y+14	; 0x0e
 146:	20 e0       	ldi	r18, 0x00	; 0
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	40 e2       	ldi	r20, 0x20	; 32
 14c:	51 e4       	ldi	r21, 0x41	; 65
 14e:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
 152:	dc 01       	movw	r26, r24
 154:	cb 01       	movw	r24, r22
 156:	bc 01       	movw	r22, r24
 158:	cd 01       	movw	r24, r26
 15a:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
 15e:	dc 01       	movw	r26, r24
 160:	cb 01       	movw	r24, r22
 162:	9e 83       	std	Y+6, r25	; 0x06
 164:	8d 83       	std	Y+5, r24	; 0x05
 166:	00 c0       	rjmp	.+0      	; 0x168 <KEYPAD_getPressedKey+0x168>
 168:	80 e9       	ldi	r24, 0x90	; 144
 16a:	91 e0       	ldi	r25, 0x01	; 1
 16c:	9c 83       	std	Y+4, r25	; 0x04
 16e:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 170:	8b 81       	ldd	r24, Y+3	; 0x03
 172:	9c 81       	ldd	r25, Y+4	; 0x04
 174:	01 97       	sbiw	r24, 0x01	; 1
 176:	01 f4       	brne	.+0      	; 0x178 <KEYPAD_getPressedKey+0x178>
 178:	9c 83       	std	Y+4, r25	; 0x04
 17a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 17c:	8d 81       	ldd	r24, Y+5	; 0x05
 17e:	9e 81       	ldd	r25, Y+6	; 0x06
 180:	01 97       	sbiw	r24, 0x01	; 1
 182:	9e 83       	std	Y+6, r25	; 0x06
 184:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 186:	8d 81       	ldd	r24, Y+5	; 0x05
 188:	9e 81       	ldd	r25, Y+6	; 0x06
 18a:	00 97       	sbiw	r24, 0x00	; 0
 18c:	01 f4       	brne	.+0      	; 0x18e <KEYPAD_getPressedKey+0x18e>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <KEYPAD_getPressedKey+0x190>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 190:	6f 81       	ldd	r22, Y+7	; 0x07
 192:	78 85       	ldd	r23, Y+8	; 0x08
 194:	89 85       	ldd	r24, Y+9	; 0x09
 196:	9a 85       	ldd	r25, Y+10	; 0x0a
 198:	0e 94 00 00 	call	0	; 0x0 <KEYPAD_getPressedKey>
 19c:	dc 01       	movw	r26, r24
 19e:	cb 01       	movw	r24, r22
 1a0:	9e 83       	std	Y+6, r25	; 0x06
 1a2:	8d 83       	std	Y+5, r24	; 0x05
 1a4:	8d 81       	ldd	r24, Y+5	; 0x05
 1a6:	9e 81       	ldd	r25, Y+6	; 0x06
 1a8:	9a 83       	std	Y+2, r25	; 0x02
 1aa:	89 83       	std	Y+1, r24	; 0x01
 1ac:	89 81       	ldd	r24, Y+1	; 0x01
 1ae:	9a 81       	ldd	r25, Y+2	; 0x02
 1b0:	01 97       	sbiw	r24, 0x01	; 1
 1b2:	01 f4       	brne	.+0      	; 0x1b4 <KEYPAD_getPressedKey+0x1b4>
 1b4:	9a 83       	std	Y+2, r25	; 0x02
 1b6:	89 83       	std	Y+1, r24	; 0x01
#if(4 == KEYPAD_NUM_COLS)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
 1b8:	8f 85       	ldd	r24, Y+15	; 0x0f
 1ba:	8f 5f       	subi	r24, 0xFF	; 255
 1bc:	8f 87       	std	Y+15, r24	; 0x0f
 1be:	8f 85       	ldd	r24, Y+15	; 0x0f
 1c0:	84 30       	cpi	r24, 0x04	; 4
 1c2:	00 f4       	brcc	.+0      	; 0x1c4 <KEYPAD_getPressedKey+0x1c4>
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <KEYPAD_getPressedKey+0x1c6>
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <__SREG__+0x189>

Disassembly of section .text.KEYPAD_4x4_adjustKeyNumber:

00000000 <KEYPAD_4x4_adjustKeyNumber>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/

uint8 KEYPAD_getPressedKey(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <KEYPAD_4x4_adjustKeyNumber+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <KEYPAD_4x4_adjustKeyNumber+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	19 82       	std	Y+1, r1	; 0x01
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	28 2f       	mov	r18, r24
	uint8 col,row;
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID, PIN_INPUT);
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+1, PIN_INPUT);
  1e:	88 30       	cpi	r24, 0x08	; 8
  20:	91 05       	cpc	r25, r1
  22:	01 f4       	brne	.+0      	; 0x24 <KEYPAD_4x4_adjustKeyNumber+0x24>
  24:	00 c0       	rjmp	.+0      	; 0x26 <KEYPAD_4x4_adjustKeyNumber+0x26>
  26:	2b 81       	ldd	r18, Y+3	; 0x03
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+2, PIN_INPUT);
  28:	3c 81       	ldd	r19, Y+4	; 0x04
  2a:	29 30       	cpi	r18, 0x09	; 9
  2c:	31 05       	cpc	r19, r1
  2e:	04 f4       	brge	.+0      	; 0x30 <KEYPAD_4x4_adjustKeyNumber+0x30>
  30:	8b 81       	ldd	r24, Y+3	; 0x03
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+3, PIN_INPUT);
  32:	9c 81       	ldd	r25, Y+4	; 0x04
  34:	84 30       	cpi	r24, 0x04	; 4
  36:	91 05       	cpc	r25, r1
  38:	01 f4       	brne	.+0      	; 0x3a <KEYPAD_4x4_adjustKeyNumber+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <KEYPAD_4x4_adjustKeyNumber+0x3c>

	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID, PIN_INPUT);
  3c:	2b 81       	ldd	r18, Y+3	; 0x03
  3e:	3c 81       	ldd	r19, Y+4	; 0x04
  40:	25 30       	cpi	r18, 0x05	; 5
  42:	31 05       	cpc	r19, r1
  44:	04 f4       	brge	.+0      	; 0x46 <KEYPAD_4x4_adjustKeyNumber+0x46>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+1, PIN_INPUT);
  46:	8b 81       	ldd	r24, Y+3	; 0x03
  48:	9c 81       	ldd	r25, Y+4	; 0x04
  4a:	82 30       	cpi	r24, 0x02	; 2
  4c:	91 05       	cpc	r25, r1
  4e:	01 f4       	brne	.+0      	; 0x50 <KEYPAD_4x4_adjustKeyNumber+0x50>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+2, PIN_INPUT);
  50:	00 c0       	rjmp	.+0      	; 0x52 <KEYPAD_4x4_adjustKeyNumber+0x52>
  52:	2b 81       	ldd	r18, Y+3	; 0x03
  54:	3c 81       	ldd	r19, Y+4	; 0x04
  56:	23 30       	cpi	r18, 0x03	; 3
  58:	31 05       	cpc	r19, r1
#if(4 == KEYPAD_NUM_COLS)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
  5a:	04 f0       	brlt	.+0      	; 0x5c <KEYPAD_4x4_adjustKeyNumber+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <KEYPAD_4x4_adjustKeyNumber+0x5e>
  5e:	8b 81       	ldd	r24, Y+3	; 0x03
  60:	9c 81       	ldd	r25, Y+4	; 0x04
  62:	81 30       	cpi	r24, 0x01	; 1
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
  64:	91 05       	cpc	r25, r1
  66:	01 f4       	brne	.+0      	; 0x68 <KEYPAD_4x4_adjustKeyNumber+0x68>
		{
			/* 
			 * Each time setup the direction for all keypad port as input pins,
			 * except this row will be output pin
			 */
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);
  68:	00 c0       	rjmp	.+0      	; 0x6a <KEYPAD_4x4_adjustKeyNumber+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <KEYPAD_4x4_adjustKeyNumber+0x6c>
  6c:	2b 81       	ldd	r18, Y+3	; 0x03
  6e:	3c 81       	ldd	r19, Y+4	; 0x04
  70:	26 30       	cpi	r18, 0x06	; 6

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);
  72:	31 05       	cpc	r19, r1
  74:	01 f4       	brne	.+0      	; 0x76 <KEYPAD_4x4_adjustKeyNumber+0x76>
  76:	00 c0       	rjmp	.+0      	; 0x78 <KEYPAD_4x4_adjustKeyNumber+0x78>
  78:	8b 81       	ldd	r24, Y+3	; 0x03
  7a:	9c 81       	ldd	r25, Y+4	; 0x04

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
  7c:	87 30       	cpi	r24, 0x07	; 7
  7e:	91 05       	cpc	r25, r1
			{
				/* Check if the switch is pressed in this column */
				if(GPIO_readPin(KEYPAD_COL_PORT_ID,KEYPAD_FIRST_COL_PIN_ID+col) == KEYPAD_BUTTON_PRESSED)
  80:	04 f0       	brlt	.+0      	; 0x82 <KEYPAD_4x4_adjustKeyNumber+0x82>
  82:	00 c0       	rjmp	.+0      	; 0x84 <KEYPAD_4x4_adjustKeyNumber+0x84>
  84:	00 c0       	rjmp	.+0      	; 0x86 <KEYPAD_4x4_adjustKeyNumber+0x86>
  86:	2b 81       	ldd	r18, Y+3	; 0x03
  88:	3c 81       	ldd	r19, Y+4	; 0x04
  8a:	2c 30       	cpi	r18, 0x0C	; 12
  8c:	31 05       	cpc	r19, r1
  8e:	01 f4       	brne	.+0      	; 0x90 <KEYPAD_4x4_adjustKeyNumber+0x90>
  90:	00 c0       	rjmp	.+0      	; 0x92 <KEYPAD_4x4_adjustKeyNumber+0x92>
						#endif
					#elif (KEYPAD_NUM_COLS == 4)
						#ifdef STANDARD_KEYPAD
							return ((row*KEYPAD_NUM_COLS)+col+1);
						#else
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
  92:	8b 81       	ldd	r24, Y+3	; 0x03
  94:	9c 81       	ldd	r25, Y+4	; 0x04
  96:	8d 30       	cpi	r24, 0x0D	; 13
  98:	91 05       	cpc	r25, r1
  9a:	04 f4       	brge	.+0      	; 0x9c <KEYPAD_4x4_adjustKeyNumber+0x9c>
  9c:	2b 81       	ldd	r18, Y+3	; 0x03
  9e:	3c 81       	ldd	r19, Y+4	; 0x04
  a0:	2a 30       	cpi	r18, 0x0A	; 10
  a2:	31 05       	cpc	r19, r1
  a4:	01 f0       	breq	.+0      	; 0xa6 <KEYPAD_4x4_adjustKeyNumber+0xa6>
  a6:	8b 81       	ldd	r24, Y+3	; 0x03
  a8:	9c 81       	ldd	r25, Y+4	; 0x04
  aa:	8b 30       	cpi	r24, 0x0B	; 11
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
			_delay_ms(5); /* Add small delay to fix CPU load issue in proteus */
		}
	}	
}
  ac:	91 05       	cpc	r25, r1
  ae:	04 f4       	brge	.+0      	; 0xb0 <KEYPAD_4x4_adjustKeyNumber+0xb0>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <KEYPAD_4x4_adjustKeyNumber+0xb2>
  b2:	2b 81       	ldd	r18, Y+3	; 0x03
  b4:	3c 81       	ldd	r19, Y+4	; 0x04
  b6:	2e 30       	cpi	r18, 0x0E	; 14
  b8:	31 05       	cpc	r19, r1
  ba:	01 f0       	breq	.+0      	; 0xbc <KEYPAD_4x4_adjustKeyNumber+0xbc>
  bc:	8b 81       	ldd	r24, Y+3	; 0x03
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
  be:	9c 81       	ldd	r25, Y+4	; 0x04
  c0:	8e 30       	cpi	r24, 0x0E	; 14
  c2:	91 05       	cpc	r25, r1
  c4:	04 f0       	brlt	.+0      	; 0xc6 <KEYPAD_4x4_adjustKeyNumber+0xc6>
  c6:	2b 81       	ldd	r18, Y+3	; 0x03
  c8:	3c 81       	ldd	r19, Y+4	; 0x04
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
						#endif
					#endif
				}
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
  ca:	2f 30       	cpi	r18, 0x0F	; 15
  cc:	31 05       	cpc	r19, r1
  ce:	01 f0       	breq	.+0      	; 0xd0 <KEYPAD_4x4_adjustKeyNumber+0xd0>
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	9c 81       	ldd	r25, Y+4	; 0x04
  d4:	80 31       	cpi	r24, 0x10	; 16
  d6:	91 05       	cpc	r25, r1
  d8:	01 f0       	breq	.+0      	; 0xda <KEYPAD_4x4_adjustKeyNumber+0xda>
  da:	00 c0       	rjmp	.+0      	; 0xdc <KEYPAD_4x4_adjustKeyNumber+0xdc>
  dc:	87 e0       	ldi	r24, 0x07	; 7
  de:	89 83       	std	Y+1, r24	; 0x01
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <KEYPAD_4x4_adjustKeyNumber+0xe2>
  e2:	88 e0       	ldi	r24, 0x08	; 8
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  e4:	89 83       	std	Y+1, r24	; 0x01
  e6:	00 c0       	rjmp	.+0      	; 0xe8 <KEYPAD_4x4_adjustKeyNumber+0xe8>
  e8:	89 e0       	ldi	r24, 0x09	; 9
  ea:	89 83       	std	Y+1, r24	; 0x01
  ec:	00 c0       	rjmp	.+0      	; 0xee <KEYPAD_4x4_adjustKeyNumber+0xee>
  ee:	85 e2       	ldi	r24, 0x25	; 37
  f0:	89 83       	std	Y+1, r24	; 0x01
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <KEYPAD_4x4_adjustKeyNumber+0xf4>
  f4:	84 e0       	ldi	r24, 0x04	; 4
  f6:	89 83       	std	Y+1, r24	; 0x01
  f8:	00 c0       	rjmp	.+0      	; 0xfa <KEYPAD_4x4_adjustKeyNumber+0xfa>
  fa:	85 e0       	ldi	r24, 0x05	; 5
  fc:	89 83       	std	Y+1, r24	; 0x01
  fe:	00 c0       	rjmp	.+0      	; 0x100 <KEYPAD_4x4_adjustKeyNumber+0x100>
 100:	86 e0       	ldi	r24, 0x06	; 6
 102:	89 83       	std	Y+1, r24	; 0x01
	if (__tmp < 1.0)
 104:	00 c0       	rjmp	.+0      	; 0x106 <KEYPAD_4x4_adjustKeyNumber+0x106>
 106:	8a e2       	ldi	r24, 0x2A	; 42
 108:	89 83       	std	Y+1, r24	; 0x01
 10a:	00 c0       	rjmp	.+0      	; 0x10c <KEYPAD_4x4_adjustKeyNumber+0x10c>
 10c:	81 e0       	ldi	r24, 0x01	; 1
 10e:	89 83       	std	Y+1, r24	; 0x01
 110:	00 c0       	rjmp	.+0      	; 0x112 <KEYPAD_4x4_adjustKeyNumber+0x112>
 112:	82 e0       	ldi	r24, 0x02	; 2
 114:	89 83       	std	Y+1, r24	; 0x01
 116:	00 c0       	rjmp	.+0      	; 0x118 <KEYPAD_4x4_adjustKeyNumber+0x118>
 118:	83 e0       	ldi	r24, 0x03	; 3
 11a:	89 83       	std	Y+1, r24	; 0x01
		__ticks = 1;
 11c:	00 c0       	rjmp	.+0      	; 0x11e <KEYPAD_4x4_adjustKeyNumber+0x11e>
 11e:	8d e2       	ldi	r24, 0x2D	; 45
 120:	89 83       	std	Y+1, r24	; 0x01
 122:	00 c0       	rjmp	.+0      	; 0x124 <KEYPAD_4x4_adjustKeyNumber+0x124>
 124:	8d e0       	ldi	r24, 0x0D	; 13
	else if (__tmp > 65535)
 126:	89 83       	std	Y+1, r24	; 0x01
 128:	00 c0       	rjmp	.+0      	; 0x12a <KEYPAD_4x4_adjustKeyNumber+0x12a>
 12a:	19 82       	std	Y+1, r1	; 0x01
 12c:	00 c0       	rjmp	.+0      	; 0x12e <KEYPAD_4x4_adjustKeyNumber+0x12e>
 12e:	8d e3       	ldi	r24, 0x3D	; 61
 130:	89 83       	std	Y+1, r24	; 0x01
 132:	00 c0       	rjmp	.+0      	; 0x134 <KEYPAD_4x4_adjustKeyNumber+0x134>
 134:	8b e2       	ldi	r24, 0x2B	; 43
 136:	89 83       	std	Y+1, r24	; 0x01
 138:	00 c0       	rjmp	.+0      	; 0x13a <KEYPAD_4x4_adjustKeyNumber+0x13a>
 13a:	8a 81       	ldd	r24, Y+2	; 0x02
 13c:	89 83       	std	Y+1, r24	; 0x01
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 13e:	89 81       	ldd	r24, Y+1	; 0x01
 140:	0f 90       	pop	r0
 142:	0f 90       	pop	r0
 144:	0f 90       	pop	r0
 146:	0f 90       	pop	r0
 148:	cf 91       	pop	r28
 14a:	df 91       	pop	r29
 14c:	08 95       	ret

lcd.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000d98  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001343  00000000  00000000  00000dcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.LCD_init 00000138  00000000  00000000  0000210f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.LCD_sendCommand 000003de  00000000  00000000  00002247  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.LCD_displayCharacter 000003de  00000000  00000000  00002625  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.LCD_displayString 00000052  00000000  00000000  00002a03  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.LCD_moveCursor 00000084  00000000  00000000  00002a55  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.LCD_displayStringRowColumn 00000032  00000000  00000000  00002ad9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.LCD_intgerToString 00000046  00000000  00000000  00002b0b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.LCD_clearScreen 00000014  00000000  00000000  00002b51  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.LCD_init:

00000000 <LCD_init>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	2e 97       	sbiw	r28, 0x0e	; 14
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
}
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	82 e0       	ldi	r24, 0x02	; 2
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	41 e0       	ldi	r20, 0x01	; 1
  1a:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  1e:	82 e0       	ldi	r24, 0x02	; 2
  20:	61 e0       	ldi	r22, 0x01	; 1
  22:	41 e0       	ldi	r20, 0x01	; 1
  24:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	a0 ea       	ldi	r26, 0xA0	; 160
  2e:	b1 e4       	ldi	r27, 0x41	; 65
  30:	8b 87       	std	Y+11, r24	; 0x0b
  32:	9c 87       	std	Y+12, r25	; 0x0c
  34:	ad 87       	std	Y+13, r26	; 0x0d
  36:	be 87       	std	Y+14, r27	; 0x0e
  38:	6b 85       	ldd	r22, Y+11	; 0x0b
  3a:	7c 85       	ldd	r23, Y+12	; 0x0c
  3c:	8d 85       	ldd	r24, Y+13	; 0x0d
  3e:	9e 85       	ldd	r25, Y+14	; 0x0e
  40:	20 e0       	ldi	r18, 0x00	; 0
  42:	30 e0       	ldi	r19, 0x00	; 0
  44:	4a e7       	ldi	r20, 0x7A	; 122
  46:	55 e4       	ldi	r21, 0x45	; 69
  48:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  4c:	dc 01       	movw	r26, r24
  4e:	cb 01       	movw	r24, r22
  50:	8f 83       	std	Y+7, r24	; 0x07
  52:	98 87       	std	Y+8, r25	; 0x08
  54:	a9 87       	std	Y+9, r26	; 0x09
  56:	ba 87       	std	Y+10, r27	; 0x0a
  58:	6f 81       	ldd	r22, Y+7	; 0x07
  5a:	78 85       	ldd	r23, Y+8	; 0x08
  5c:	89 85       	ldd	r24, Y+9	; 0x09
  5e:	9a 85       	ldd	r25, Y+10	; 0x0a
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	30 e0       	ldi	r19, 0x00	; 0
  64:	40 e8       	ldi	r20, 0x80	; 128
  66:	5f e3       	ldi	r21, 0x3F	; 63
  68:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  6c:	88 23       	and	r24, r24
  6e:	04 f4       	brge	.+0      	; 0x70 <LCD_init+0x70>
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	90 e0       	ldi	r25, 0x00	; 0
  74:	9e 83       	std	Y+6, r25	; 0x06
  76:	8d 83       	std	Y+5, r24	; 0x05
  78:	00 c0       	rjmp	.+0      	; 0x7a <LCD_init+0x7a>
  7a:	6f 81       	ldd	r22, Y+7	; 0x07
  7c:	78 85       	ldd	r23, Y+8	; 0x08
  7e:	89 85       	ldd	r24, Y+9	; 0x09
  80:	9a 85       	ldd	r25, Y+10	; 0x0a
  82:	20 e0       	ldi	r18, 0x00	; 0
  84:	3f ef       	ldi	r19, 0xFF	; 255
  86:	4f e7       	ldi	r20, 0x7F	; 127
  88:	57 e4       	ldi	r21, 0x47	; 71
  8a:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  8e:	18 16       	cp	r1, r24
  90:	04 f4       	brge	.+0      	; 0x92 <LCD_init+0x92>
  92:	6b 85       	ldd	r22, Y+11	; 0x0b
  94:	7c 85       	ldd	r23, Y+12	; 0x0c
  96:	8d 85       	ldd	r24, Y+13	; 0x0d
  98:	9e 85       	ldd	r25, Y+14	; 0x0e
  9a:	20 e0       	ldi	r18, 0x00	; 0
  9c:	30 e0       	ldi	r19, 0x00	; 0
  9e:	40 e2       	ldi	r20, 0x20	; 32
  a0:	51 e4       	ldi	r21, 0x41	; 65
  a2:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  a6:	dc 01       	movw	r26, r24
  a8:	cb 01       	movw	r24, r22
  aa:	bc 01       	movw	r22, r24
  ac:	cd 01       	movw	r24, r26
  ae:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  b2:	dc 01       	movw	r26, r24
  b4:	cb 01       	movw	r24, r22
  b6:	9e 83       	std	Y+6, r25	; 0x06
  b8:	8d 83       	std	Y+5, r24	; 0x05
  ba:	00 c0       	rjmp	.+0      	; 0xbc <LCD_init+0xbc>
  bc:	80 e9       	ldi	r24, 0x90	; 144
  be:	91 e0       	ldi	r25, 0x01	; 1
  c0:	9c 83       	std	Y+4, r25	; 0x04
  c2:	8b 83       	std	Y+3, r24	; 0x03
  c4:	8b 81       	ldd	r24, Y+3	; 0x03
  c6:	9c 81       	ldd	r25, Y+4	; 0x04
  c8:	01 97       	sbiw	r24, 0x01	; 1
  ca:	01 f4       	brne	.+0      	; 0xcc <LCD_init+0xcc>
  cc:	9c 83       	std	Y+4, r25	; 0x04
  ce:	8b 83       	std	Y+3, r24	; 0x03
  d0:	8d 81       	ldd	r24, Y+5	; 0x05
  d2:	9e 81       	ldd	r25, Y+6	; 0x06
  d4:	01 97       	sbiw	r24, 0x01	; 1
  d6:	9e 83       	std	Y+6, r25	; 0x06
  d8:	8d 83       	std	Y+5, r24	; 0x05
  da:	8d 81       	ldd	r24, Y+5	; 0x05
  dc:	9e 81       	ldd	r25, Y+6	; 0x06
  de:	00 97       	sbiw	r24, 0x00	; 0
  e0:	01 f4       	brne	.+0      	; 0xe2 <LCD_init+0xe2>
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <LCD_init+0xe4>
  e4:	6f 81       	ldd	r22, Y+7	; 0x07
  e6:	78 85       	ldd	r23, Y+8	; 0x08
  e8:	89 85       	ldd	r24, Y+9	; 0x09
  ea:	9a 85       	ldd	r25, Y+10	; 0x0a
  ec:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
  f0:	dc 01       	movw	r26, r24
  f2:	cb 01       	movw	r24, r22
  f4:	9e 83       	std	Y+6, r25	; 0x06
  f6:	8d 83       	std	Y+5, r24	; 0x05
  f8:	8d 81       	ldd	r24, Y+5	; 0x05
  fa:	9e 81       	ldd	r25, Y+6	; 0x06
  fc:	9a 83       	std	Y+2, r25	; 0x02
  fe:	89 83       	std	Y+1, r24	; 0x01
 100:	89 81       	ldd	r24, Y+1	; 0x01
 102:	9a 81       	ldd	r25, Y+2	; 0x02
 104:	01 97       	sbiw	r24, 0x01	; 1
 106:	01 f4       	brne	.+0      	; 0x108 <LCD_init+0x108>
 108:	9a 83       	std	Y+2, r25	; 0x02
 10a:	89 83       	std	Y+1, r24	; 0x01
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	6f ef       	ldi	r22, 0xFF	; 255
 110:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
 114:	88 e3       	ldi	r24, 0x38	; 56
 116:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
 11a:	8c e0       	ldi	r24, 0x0C	; 12
 11c:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
 120:	81 e0       	ldi	r24, 0x01	; 1
 122:	0e 94 00 00 	call	0	; 0x0 <LCD_init>
 126:	2e 96       	adiw	r28, 0x0e	; 14
 128:	0f b6       	in	r0, 0x3f	; 63
 12a:	f8 94       	cli
 12c:	de bf       	out	0x3e, r29	; 62
 12e:	0f be       	out	0x3f, r0	; 63
 130:	cd bf       	out	0x3d, r28	; 61
 132:	cf 91       	pop	r28
 134:	df 91       	pop	r29
 136:	08 95       	ret

Disassembly of section .text.LCD_sendCommand:

00000000 <LCD_sendCommand>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	e9 97       	sbiw	r28, 0x39	; 57
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
}
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 af       	std	Y+57, r24	; 0x39
  16:	82 e0       	ldi	r24, 0x02	; 2
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	40 e0       	ldi	r20, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  20:	80 e0       	ldi	r24, 0x00	; 0
  22:	90 e0       	ldi	r25, 0x00	; 0
  24:	a0 e8       	ldi	r26, 0x80	; 128
  26:	bf e3       	ldi	r27, 0x3F	; 63
  28:	8d ab       	std	Y+53, r24	; 0x35
  2a:	9e ab       	std	Y+54, r25	; 0x36
  2c:	af ab       	std	Y+55, r26	; 0x37
  2e:	b8 af       	std	Y+56, r27	; 0x38
  30:	6d a9       	ldd	r22, Y+53	; 0x35
  32:	7e a9       	ldd	r23, Y+54	; 0x36
  34:	8f a9       	ldd	r24, Y+55	; 0x37
  36:	98 ad       	ldd	r25, Y+56	; 0x38
  38:	20 e0       	ldi	r18, 0x00	; 0
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	4a e7       	ldi	r20, 0x7A	; 122
  3e:	55 e4       	ldi	r21, 0x45	; 69
  40:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  44:	dc 01       	movw	r26, r24
  46:	cb 01       	movw	r24, r22
  48:	89 ab       	std	Y+49, r24	; 0x31
  4a:	9a ab       	std	Y+50, r25	; 0x32
  4c:	ab ab       	std	Y+51, r26	; 0x33
  4e:	bc ab       	std	Y+52, r27	; 0x34
  50:	69 a9       	ldd	r22, Y+49	; 0x31
  52:	7a a9       	ldd	r23, Y+50	; 0x32
  54:	8b a9       	ldd	r24, Y+51	; 0x33
  56:	9c a9       	ldd	r25, Y+52	; 0x34
  58:	20 e0       	ldi	r18, 0x00	; 0
  5a:	30 e0       	ldi	r19, 0x00	; 0
  5c:	40 e8       	ldi	r20, 0x80	; 128
  5e:	5f e3       	ldi	r21, 0x3F	; 63
  60:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  64:	88 23       	and	r24, r24
  66:	04 f4       	brge	.+0      	; 0x68 <LCD_sendCommand+0x68>
  68:	81 e0       	ldi	r24, 0x01	; 1
  6a:	90 e0       	ldi	r25, 0x00	; 0
  6c:	98 ab       	std	Y+48, r25	; 0x30
  6e:	8f a7       	std	Y+47, r24	; 0x2f
  70:	00 c0       	rjmp	.+0      	; 0x72 <LCD_sendCommand+0x72>
  72:	69 a9       	ldd	r22, Y+49	; 0x31
  74:	7a a9       	ldd	r23, Y+50	; 0x32
  76:	8b a9       	ldd	r24, Y+51	; 0x33
  78:	9c a9       	ldd	r25, Y+52	; 0x34
  7a:	20 e0       	ldi	r18, 0x00	; 0
  7c:	3f ef       	ldi	r19, 0xFF	; 255
  7e:	4f e7       	ldi	r20, 0x7F	; 127
  80:	57 e4       	ldi	r21, 0x47	; 71
  82:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  86:	18 16       	cp	r1, r24
  88:	04 f4       	brge	.+0      	; 0x8a <LCD_sendCommand+0x8a>
  8a:	6d a9       	ldd	r22, Y+53	; 0x35
  8c:	7e a9       	ldd	r23, Y+54	; 0x36
  8e:	8f a9       	ldd	r24, Y+55	; 0x37
  90:	98 ad       	ldd	r25, Y+56	; 0x38
  92:	20 e0       	ldi	r18, 0x00	; 0
  94:	30 e0       	ldi	r19, 0x00	; 0
  96:	40 e2       	ldi	r20, 0x20	; 32
  98:	51 e4       	ldi	r21, 0x41	; 65
  9a:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  9e:	dc 01       	movw	r26, r24
  a0:	cb 01       	movw	r24, r22
  a2:	bc 01       	movw	r22, r24
  a4:	cd 01       	movw	r24, r26
  a6:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  aa:	dc 01       	movw	r26, r24
  ac:	cb 01       	movw	r24, r22
  ae:	98 ab       	std	Y+48, r25	; 0x30
  b0:	8f a7       	std	Y+47, r24	; 0x2f
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <LCD_sendCommand+0xb4>
  b4:	80 e9       	ldi	r24, 0x90	; 144
  b6:	91 e0       	ldi	r25, 0x01	; 1
  b8:	9e a7       	std	Y+46, r25	; 0x2e
  ba:	8d a7       	std	Y+45, r24	; 0x2d
  bc:	8d a5       	ldd	r24, Y+45	; 0x2d
  be:	9e a5       	ldd	r25, Y+46	; 0x2e
  c0:	01 97       	sbiw	r24, 0x01	; 1
  c2:	01 f4       	brne	.+0      	; 0xc4 <LCD_sendCommand+0xc4>
  c4:	9e a7       	std	Y+46, r25	; 0x2e
  c6:	8d a7       	std	Y+45, r24	; 0x2d
  c8:	8f a5       	ldd	r24, Y+47	; 0x2f
  ca:	98 a9       	ldd	r25, Y+48	; 0x30
  cc:	01 97       	sbiw	r24, 0x01	; 1
  ce:	98 ab       	std	Y+48, r25	; 0x30
  d0:	8f a7       	std	Y+47, r24	; 0x2f
  d2:	8f a5       	ldd	r24, Y+47	; 0x2f
  d4:	98 a9       	ldd	r25, Y+48	; 0x30
  d6:	00 97       	sbiw	r24, 0x00	; 0
  d8:	01 f4       	brne	.+0      	; 0xda <LCD_sendCommand+0xda>
  da:	00 c0       	rjmp	.+0      	; 0xdc <LCD_sendCommand+0xdc>
  dc:	69 a9       	ldd	r22, Y+49	; 0x31
  de:	7a a9       	ldd	r23, Y+50	; 0x32
  e0:	8b a9       	ldd	r24, Y+51	; 0x33
  e2:	9c a9       	ldd	r25, Y+52	; 0x34
  e4:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
  e8:	dc 01       	movw	r26, r24
  ea:	cb 01       	movw	r24, r22
  ec:	98 ab       	std	Y+48, r25	; 0x30
  ee:	8f a7       	std	Y+47, r24	; 0x2f
  f0:	8f a5       	ldd	r24, Y+47	; 0x2f
  f2:	98 a9       	ldd	r25, Y+48	; 0x30
  f4:	9c a7       	std	Y+44, r25	; 0x2c
  f6:	8b a7       	std	Y+43, r24	; 0x2b
  f8:	8b a5       	ldd	r24, Y+43	; 0x2b
  fa:	9c a5       	ldd	r25, Y+44	; 0x2c
  fc:	01 97       	sbiw	r24, 0x01	; 1
  fe:	01 f4       	brne	.+0      	; 0x100 <LCD_sendCommand+0x100>
 100:	9c a7       	std	Y+44, r25	; 0x2c
 102:	8b a7       	std	Y+43, r24	; 0x2b
 104:	82 e0       	ldi	r24, 0x02	; 2
 106:	61 e0       	ldi	r22, 0x01	; 1
 108:	41 e0       	ldi	r20, 0x01	; 1
 10a:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	a0 e8       	ldi	r26, 0x80	; 128
 114:	bf e3       	ldi	r27, 0x3F	; 63
 116:	8f a3       	std	Y+39, r24	; 0x27
 118:	98 a7       	std	Y+40, r25	; 0x28
 11a:	a9 a7       	std	Y+41, r26	; 0x29
 11c:	ba a7       	std	Y+42, r27	; 0x2a
 11e:	6f a1       	ldd	r22, Y+39	; 0x27
 120:	78 a5       	ldd	r23, Y+40	; 0x28
 122:	89 a5       	ldd	r24, Y+41	; 0x29
 124:	9a a5       	ldd	r25, Y+42	; 0x2a
 126:	20 e0       	ldi	r18, 0x00	; 0
 128:	30 e0       	ldi	r19, 0x00	; 0
 12a:	4a e7       	ldi	r20, 0x7A	; 122
 12c:	55 e4       	ldi	r21, 0x45	; 69
 12e:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 132:	dc 01       	movw	r26, r24
 134:	cb 01       	movw	r24, r22
 136:	8b a3       	std	Y+35, r24	; 0x23
 138:	9c a3       	std	Y+36, r25	; 0x24
 13a:	ad a3       	std	Y+37, r26	; 0x25
 13c:	be a3       	std	Y+38, r27	; 0x26
 13e:	6b a1       	ldd	r22, Y+35	; 0x23
 140:	7c a1       	ldd	r23, Y+36	; 0x24
 142:	8d a1       	ldd	r24, Y+37	; 0x25
 144:	9e a1       	ldd	r25, Y+38	; 0x26
 146:	20 e0       	ldi	r18, 0x00	; 0
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	40 e8       	ldi	r20, 0x80	; 128
 14c:	5f e3       	ldi	r21, 0x3F	; 63
 14e:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 152:	88 23       	and	r24, r24
 154:	04 f4       	brge	.+0      	; 0x156 <LCD_sendCommand+0x156>
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	9a a3       	std	Y+34, r25	; 0x22
 15c:	89 a3       	std	Y+33, r24	; 0x21
 15e:	00 c0       	rjmp	.+0      	; 0x160 <LCD_sendCommand+0x160>
 160:	6b a1       	ldd	r22, Y+35	; 0x23
 162:	7c a1       	ldd	r23, Y+36	; 0x24
 164:	8d a1       	ldd	r24, Y+37	; 0x25
 166:	9e a1       	ldd	r25, Y+38	; 0x26
 168:	20 e0       	ldi	r18, 0x00	; 0
 16a:	3f ef       	ldi	r19, 0xFF	; 255
 16c:	4f e7       	ldi	r20, 0x7F	; 127
 16e:	57 e4       	ldi	r21, 0x47	; 71
 170:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 174:	18 16       	cp	r1, r24
 176:	04 f4       	brge	.+0      	; 0x178 <LCD_sendCommand+0x178>
 178:	6f a1       	ldd	r22, Y+39	; 0x27
 17a:	78 a5       	ldd	r23, Y+40	; 0x28
 17c:	89 a5       	ldd	r24, Y+41	; 0x29
 17e:	9a a5       	ldd	r25, Y+42	; 0x2a
 180:	20 e0       	ldi	r18, 0x00	; 0
 182:	30 e0       	ldi	r19, 0x00	; 0
 184:	40 e2       	ldi	r20, 0x20	; 32
 186:	51 e4       	ldi	r21, 0x41	; 65
 188:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 18c:	dc 01       	movw	r26, r24
 18e:	cb 01       	movw	r24, r22
 190:	bc 01       	movw	r22, r24
 192:	cd 01       	movw	r24, r26
 194:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 198:	dc 01       	movw	r26, r24
 19a:	cb 01       	movw	r24, r22
 19c:	9a a3       	std	Y+34, r25	; 0x22
 19e:	89 a3       	std	Y+33, r24	; 0x21
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <LCD_sendCommand+0x1a2>
 1a2:	80 e9       	ldi	r24, 0x90	; 144
 1a4:	91 e0       	ldi	r25, 0x01	; 1
 1a6:	98 a3       	std	Y+32, r25	; 0x20
 1a8:	8f 8f       	std	Y+31, r24	; 0x1f
 1aa:	8f 8d       	ldd	r24, Y+31	; 0x1f
 1ac:	98 a1       	ldd	r25, Y+32	; 0x20
 1ae:	01 97       	sbiw	r24, 0x01	; 1
 1b0:	01 f4       	brne	.+0      	; 0x1b2 <LCD_sendCommand+0x1b2>
 1b2:	98 a3       	std	Y+32, r25	; 0x20
 1b4:	8f 8f       	std	Y+31, r24	; 0x1f
 1b6:	89 a1       	ldd	r24, Y+33	; 0x21
 1b8:	9a a1       	ldd	r25, Y+34	; 0x22
 1ba:	01 97       	sbiw	r24, 0x01	; 1
 1bc:	9a a3       	std	Y+34, r25	; 0x22
 1be:	89 a3       	std	Y+33, r24	; 0x21
 1c0:	89 a1       	ldd	r24, Y+33	; 0x21
 1c2:	9a a1       	ldd	r25, Y+34	; 0x22
 1c4:	00 97       	sbiw	r24, 0x00	; 0
 1c6:	01 f4       	brne	.+0      	; 0x1c8 <LCD_sendCommand+0x1c8>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <LCD_sendCommand+0x1ca>
 1ca:	6b a1       	ldd	r22, Y+35	; 0x23
 1cc:	7c a1       	ldd	r23, Y+36	; 0x24
 1ce:	8d a1       	ldd	r24, Y+37	; 0x25
 1d0:	9e a1       	ldd	r25, Y+38	; 0x26
 1d2:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 1d6:	dc 01       	movw	r26, r24
 1d8:	cb 01       	movw	r24, r22
 1da:	9a a3       	std	Y+34, r25	; 0x22
 1dc:	89 a3       	std	Y+33, r24	; 0x21
 1de:	89 a1       	ldd	r24, Y+33	; 0x21
 1e0:	9a a1       	ldd	r25, Y+34	; 0x22
 1e2:	9e 8f       	std	Y+30, r25	; 0x1e
 1e4:	8d 8f       	std	Y+29, r24	; 0x1d
 1e6:	8d 8d       	ldd	r24, Y+29	; 0x1d
 1e8:	9e 8d       	ldd	r25, Y+30	; 0x1e
 1ea:	01 97       	sbiw	r24, 0x01	; 1
 1ec:	01 f4       	brne	.+0      	; 0x1ee <LCD_sendCommand+0x1ee>
 1ee:	9e 8f       	std	Y+30, r25	; 0x1e
 1f0:	8d 8f       	std	Y+29, r24	; 0x1d
 1f2:	80 e0       	ldi	r24, 0x00	; 0
 1f4:	69 ad       	ldd	r22, Y+57	; 0x39
 1f6:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 1fa:	80 e0       	ldi	r24, 0x00	; 0
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	a0 e8       	ldi	r26, 0x80	; 128
 200:	bf e3       	ldi	r27, 0x3F	; 63
 202:	89 8f       	std	Y+25, r24	; 0x19
 204:	9a 8f       	std	Y+26, r25	; 0x1a
 206:	ab 8f       	std	Y+27, r26	; 0x1b
 208:	bc 8f       	std	Y+28, r27	; 0x1c
 20a:	69 8d       	ldd	r22, Y+25	; 0x19
 20c:	7a 8d       	ldd	r23, Y+26	; 0x1a
 20e:	8b 8d       	ldd	r24, Y+27	; 0x1b
 210:	9c 8d       	ldd	r25, Y+28	; 0x1c
 212:	20 e0       	ldi	r18, 0x00	; 0
 214:	30 e0       	ldi	r19, 0x00	; 0
 216:	4a e7       	ldi	r20, 0x7A	; 122
 218:	55 e4       	ldi	r21, 0x45	; 69
 21a:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 21e:	dc 01       	movw	r26, r24
 220:	cb 01       	movw	r24, r22
 222:	8d 8b       	std	Y+21, r24	; 0x15
 224:	9e 8b       	std	Y+22, r25	; 0x16
 226:	af 8b       	std	Y+23, r26	; 0x17
 228:	b8 8f       	std	Y+24, r27	; 0x18
 22a:	6d 89       	ldd	r22, Y+21	; 0x15
 22c:	7e 89       	ldd	r23, Y+22	; 0x16
 22e:	8f 89       	ldd	r24, Y+23	; 0x17
 230:	98 8d       	ldd	r25, Y+24	; 0x18
 232:	20 e0       	ldi	r18, 0x00	; 0
 234:	30 e0       	ldi	r19, 0x00	; 0
 236:	40 e8       	ldi	r20, 0x80	; 128
 238:	5f e3       	ldi	r21, 0x3F	; 63
 23a:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 23e:	88 23       	and	r24, r24
 240:	04 f4       	brge	.+0      	; 0x242 <LCD_sendCommand+0x242>
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	90 e0       	ldi	r25, 0x00	; 0
 246:	9c 8b       	std	Y+20, r25	; 0x14
 248:	8b 8b       	std	Y+19, r24	; 0x13
 24a:	00 c0       	rjmp	.+0      	; 0x24c <LCD_sendCommand+0x24c>
 24c:	6d 89       	ldd	r22, Y+21	; 0x15
 24e:	7e 89       	ldd	r23, Y+22	; 0x16
 250:	8f 89       	ldd	r24, Y+23	; 0x17
 252:	98 8d       	ldd	r25, Y+24	; 0x18
 254:	20 e0       	ldi	r18, 0x00	; 0
 256:	3f ef       	ldi	r19, 0xFF	; 255
 258:	4f e7       	ldi	r20, 0x7F	; 127
 25a:	57 e4       	ldi	r21, 0x47	; 71
 25c:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 260:	18 16       	cp	r1, r24
 262:	04 f4       	brge	.+0      	; 0x264 <LCD_sendCommand+0x264>
 264:	69 8d       	ldd	r22, Y+25	; 0x19
 266:	7a 8d       	ldd	r23, Y+26	; 0x1a
 268:	8b 8d       	ldd	r24, Y+27	; 0x1b
 26a:	9c 8d       	ldd	r25, Y+28	; 0x1c
 26c:	20 e0       	ldi	r18, 0x00	; 0
 26e:	30 e0       	ldi	r19, 0x00	; 0
 270:	40 e2       	ldi	r20, 0x20	; 32
 272:	51 e4       	ldi	r21, 0x41	; 65
 274:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 278:	dc 01       	movw	r26, r24
 27a:	cb 01       	movw	r24, r22
 27c:	bc 01       	movw	r22, r24
 27e:	cd 01       	movw	r24, r26
 280:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 284:	dc 01       	movw	r26, r24
 286:	cb 01       	movw	r24, r22
 288:	9c 8b       	std	Y+20, r25	; 0x14
 28a:	8b 8b       	std	Y+19, r24	; 0x13
 28c:	00 c0       	rjmp	.+0      	; 0x28e <LCD_sendCommand+0x28e>
 28e:	80 e9       	ldi	r24, 0x90	; 144
 290:	91 e0       	ldi	r25, 0x01	; 1
 292:	9a 8b       	std	Y+18, r25	; 0x12
 294:	89 8b       	std	Y+17, r24	; 0x11
 296:	89 89       	ldd	r24, Y+17	; 0x11
 298:	9a 89       	ldd	r25, Y+18	; 0x12
 29a:	01 97       	sbiw	r24, 0x01	; 1
 29c:	01 f4       	brne	.+0      	; 0x29e <LCD_sendCommand+0x29e>
 29e:	9a 8b       	std	Y+18, r25	; 0x12
 2a0:	89 8b       	std	Y+17, r24	; 0x11
 2a2:	8b 89       	ldd	r24, Y+19	; 0x13
 2a4:	9c 89       	ldd	r25, Y+20	; 0x14
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	9c 8b       	std	Y+20, r25	; 0x14
 2aa:	8b 8b       	std	Y+19, r24	; 0x13
 2ac:	8b 89       	ldd	r24, Y+19	; 0x13
 2ae:	9c 89       	ldd	r25, Y+20	; 0x14
 2b0:	00 97       	sbiw	r24, 0x00	; 0
 2b2:	01 f4       	brne	.+0      	; 0x2b4 <LCD_sendCommand+0x2b4>
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <LCD_sendCommand+0x2b6>
 2b6:	6d 89       	ldd	r22, Y+21	; 0x15
 2b8:	7e 89       	ldd	r23, Y+22	; 0x16
 2ba:	8f 89       	ldd	r24, Y+23	; 0x17
 2bc:	98 8d       	ldd	r25, Y+24	; 0x18
 2be:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 2c2:	dc 01       	movw	r26, r24
 2c4:	cb 01       	movw	r24, r22
 2c6:	9c 8b       	std	Y+20, r25	; 0x14
 2c8:	8b 8b       	std	Y+19, r24	; 0x13
 2ca:	8b 89       	ldd	r24, Y+19	; 0x13
 2cc:	9c 89       	ldd	r25, Y+20	; 0x14
 2ce:	98 8b       	std	Y+16, r25	; 0x10
 2d0:	8f 87       	std	Y+15, r24	; 0x0f
 2d2:	8f 85       	ldd	r24, Y+15	; 0x0f
 2d4:	98 89       	ldd	r25, Y+16	; 0x10
 2d6:	01 97       	sbiw	r24, 0x01	; 1
 2d8:	01 f4       	brne	.+0      	; 0x2da <LCD_sendCommand+0x2da>
 2da:	98 8b       	std	Y+16, r25	; 0x10
 2dc:	8f 87       	std	Y+15, r24	; 0x0f
 2de:	82 e0       	ldi	r24, 0x02	; 2
 2e0:	61 e0       	ldi	r22, 0x01	; 1
 2e2:	40 e0       	ldi	r20, 0x00	; 0
 2e4:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 2e8:	80 e0       	ldi	r24, 0x00	; 0
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	a0 e8       	ldi	r26, 0x80	; 128
 2ee:	bf e3       	ldi	r27, 0x3F	; 63
 2f0:	8b 87       	std	Y+11, r24	; 0x0b
 2f2:	9c 87       	std	Y+12, r25	; 0x0c
 2f4:	ad 87       	std	Y+13, r26	; 0x0d
 2f6:	be 87       	std	Y+14, r27	; 0x0e
 2f8:	6b 85       	ldd	r22, Y+11	; 0x0b
 2fa:	7c 85       	ldd	r23, Y+12	; 0x0c
 2fc:	8d 85       	ldd	r24, Y+13	; 0x0d
 2fe:	9e 85       	ldd	r25, Y+14	; 0x0e
 300:	20 e0       	ldi	r18, 0x00	; 0
 302:	30 e0       	ldi	r19, 0x00	; 0
 304:	4a e7       	ldi	r20, 0x7A	; 122
 306:	55 e4       	ldi	r21, 0x45	; 69
 308:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 30c:	dc 01       	movw	r26, r24
 30e:	cb 01       	movw	r24, r22
 310:	8f 83       	std	Y+7, r24	; 0x07
 312:	98 87       	std	Y+8, r25	; 0x08
 314:	a9 87       	std	Y+9, r26	; 0x09
 316:	ba 87       	std	Y+10, r27	; 0x0a
 318:	6f 81       	ldd	r22, Y+7	; 0x07
 31a:	78 85       	ldd	r23, Y+8	; 0x08
 31c:	89 85       	ldd	r24, Y+9	; 0x09
 31e:	9a 85       	ldd	r25, Y+10	; 0x0a
 320:	20 e0       	ldi	r18, 0x00	; 0
 322:	30 e0       	ldi	r19, 0x00	; 0
 324:	40 e8       	ldi	r20, 0x80	; 128
 326:	5f e3       	ldi	r21, 0x3F	; 63
 328:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 32c:	88 23       	and	r24, r24
 32e:	04 f4       	brge	.+0      	; 0x330 <LCD_sendCommand+0x330>
 330:	81 e0       	ldi	r24, 0x01	; 1
 332:	90 e0       	ldi	r25, 0x00	; 0
 334:	9e 83       	std	Y+6, r25	; 0x06
 336:	8d 83       	std	Y+5, r24	; 0x05
 338:	00 c0       	rjmp	.+0      	; 0x33a <LCD_sendCommand+0x33a>
 33a:	6f 81       	ldd	r22, Y+7	; 0x07
 33c:	78 85       	ldd	r23, Y+8	; 0x08
 33e:	89 85       	ldd	r24, Y+9	; 0x09
 340:	9a 85       	ldd	r25, Y+10	; 0x0a
 342:	20 e0       	ldi	r18, 0x00	; 0
 344:	3f ef       	ldi	r19, 0xFF	; 255
 346:	4f e7       	ldi	r20, 0x7F	; 127
 348:	57 e4       	ldi	r21, 0x47	; 71
 34a:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 34e:	18 16       	cp	r1, r24
 350:	04 f4       	brge	.+0      	; 0x352 <LCD_sendCommand+0x352>
 352:	6b 85       	ldd	r22, Y+11	; 0x0b
 354:	7c 85       	ldd	r23, Y+12	; 0x0c
 356:	8d 85       	ldd	r24, Y+13	; 0x0d
 358:	9e 85       	ldd	r25, Y+14	; 0x0e
 35a:	20 e0       	ldi	r18, 0x00	; 0
 35c:	30 e0       	ldi	r19, 0x00	; 0
 35e:	40 e2       	ldi	r20, 0x20	; 32
 360:	51 e4       	ldi	r21, 0x41	; 65
 362:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 366:	dc 01       	movw	r26, r24
 368:	cb 01       	movw	r24, r22
 36a:	bc 01       	movw	r22, r24
 36c:	cd 01       	movw	r24, r26
 36e:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 372:	dc 01       	movw	r26, r24
 374:	cb 01       	movw	r24, r22
 376:	9e 83       	std	Y+6, r25	; 0x06
 378:	8d 83       	std	Y+5, r24	; 0x05
 37a:	00 c0       	rjmp	.+0      	; 0x37c <LCD_sendCommand+0x37c>
 37c:	80 e9       	ldi	r24, 0x90	; 144
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	9c 83       	std	Y+4, r25	; 0x04
 382:	8b 83       	std	Y+3, r24	; 0x03
 384:	8b 81       	ldd	r24, Y+3	; 0x03
 386:	9c 81       	ldd	r25, Y+4	; 0x04
 388:	01 97       	sbiw	r24, 0x01	; 1
 38a:	01 f4       	brne	.+0      	; 0x38c <LCD_sendCommand+0x38c>
 38c:	9c 83       	std	Y+4, r25	; 0x04
 38e:	8b 83       	std	Y+3, r24	; 0x03
 390:	8d 81       	ldd	r24, Y+5	; 0x05
 392:	9e 81       	ldd	r25, Y+6	; 0x06
 394:	01 97       	sbiw	r24, 0x01	; 1
 396:	9e 83       	std	Y+6, r25	; 0x06
 398:	8d 83       	std	Y+5, r24	; 0x05
 39a:	8d 81       	ldd	r24, Y+5	; 0x05
 39c:	9e 81       	ldd	r25, Y+6	; 0x06
 39e:	00 97       	sbiw	r24, 0x00	; 0
 3a0:	01 f4       	brne	.+0      	; 0x3a2 <LCD_sendCommand+0x3a2>
 3a2:	00 c0       	rjmp	.+0      	; 0x3a4 <LCD_sendCommand+0x3a4>
 3a4:	6f 81       	ldd	r22, Y+7	; 0x07
 3a6:	78 85       	ldd	r23, Y+8	; 0x08
 3a8:	89 85       	ldd	r24, Y+9	; 0x09
 3aa:	9a 85       	ldd	r25, Y+10	; 0x0a
 3ac:	0e 94 00 00 	call	0	; 0x0 <LCD_sendCommand>
 3b0:	dc 01       	movw	r26, r24
 3b2:	cb 01       	movw	r24, r22
 3b4:	9e 83       	std	Y+6, r25	; 0x06
 3b6:	8d 83       	std	Y+5, r24	; 0x05
 3b8:	8d 81       	ldd	r24, Y+5	; 0x05
 3ba:	9e 81       	ldd	r25, Y+6	; 0x06
 3bc:	9a 83       	std	Y+2, r25	; 0x02
 3be:	89 83       	std	Y+1, r24	; 0x01
 3c0:	89 81       	ldd	r24, Y+1	; 0x01
 3c2:	9a 81       	ldd	r25, Y+2	; 0x02
 3c4:	01 97       	sbiw	r24, 0x01	; 1
 3c6:	01 f4       	brne	.+0      	; 0x3c8 <LCD_sendCommand+0x3c8>
 3c8:	9a 83       	std	Y+2, r25	; 0x02
 3ca:	89 83       	std	Y+1, r24	; 0x01
 3cc:	e9 96       	adiw	r28, 0x39	; 57
 3ce:	0f b6       	in	r0, 0x3f	; 63
 3d0:	f8 94       	cli
 3d2:	de bf       	out	0x3e, r29	; 62
 3d4:	0f be       	out	0x3f, r0	; 63
 3d6:	cd bf       	out	0x3d, r28	; 61
 3d8:	cf 91       	pop	r28
 3da:	df 91       	pop	r29
 3dc:	08 95       	ret

Disassembly of section .text.LCD_displayCharacter:

00000000 <LCD_displayCharacter>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	e9 97       	sbiw	r28, 0x39	; 57
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
}
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 af       	std	Y+57, r24	; 0x39
  16:	82 e0       	ldi	r24, 0x02	; 2
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	41 e0       	ldi	r20, 0x01	; 1
  1c:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  20:	80 e0       	ldi	r24, 0x00	; 0
  22:	90 e0       	ldi	r25, 0x00	; 0
  24:	a0 e8       	ldi	r26, 0x80	; 128
  26:	bf e3       	ldi	r27, 0x3F	; 63
  28:	8d ab       	std	Y+53, r24	; 0x35
  2a:	9e ab       	std	Y+54, r25	; 0x36
  2c:	af ab       	std	Y+55, r26	; 0x37
  2e:	b8 af       	std	Y+56, r27	; 0x38
  30:	6d a9       	ldd	r22, Y+53	; 0x35
  32:	7e a9       	ldd	r23, Y+54	; 0x36
  34:	8f a9       	ldd	r24, Y+55	; 0x37
  36:	98 ad       	ldd	r25, Y+56	; 0x38
  38:	20 e0       	ldi	r18, 0x00	; 0
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	4a e7       	ldi	r20, 0x7A	; 122
  3e:	55 e4       	ldi	r21, 0x45	; 69
  40:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  44:	dc 01       	movw	r26, r24
  46:	cb 01       	movw	r24, r22
  48:	89 ab       	std	Y+49, r24	; 0x31
  4a:	9a ab       	std	Y+50, r25	; 0x32
  4c:	ab ab       	std	Y+51, r26	; 0x33
  4e:	bc ab       	std	Y+52, r27	; 0x34
  50:	69 a9       	ldd	r22, Y+49	; 0x31
  52:	7a a9       	ldd	r23, Y+50	; 0x32
  54:	8b a9       	ldd	r24, Y+51	; 0x33
  56:	9c a9       	ldd	r25, Y+52	; 0x34
  58:	20 e0       	ldi	r18, 0x00	; 0
  5a:	30 e0       	ldi	r19, 0x00	; 0
  5c:	40 e8       	ldi	r20, 0x80	; 128
  5e:	5f e3       	ldi	r21, 0x3F	; 63
  60:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  64:	88 23       	and	r24, r24
  66:	04 f4       	brge	.+0      	; 0x68 <LCD_displayCharacter+0x68>
  68:	81 e0       	ldi	r24, 0x01	; 1
  6a:	90 e0       	ldi	r25, 0x00	; 0
  6c:	98 ab       	std	Y+48, r25	; 0x30
  6e:	8f a7       	std	Y+47, r24	; 0x2f
  70:	00 c0       	rjmp	.+0      	; 0x72 <LCD_displayCharacter+0x72>
  72:	69 a9       	ldd	r22, Y+49	; 0x31
  74:	7a a9       	ldd	r23, Y+50	; 0x32
  76:	8b a9       	ldd	r24, Y+51	; 0x33
  78:	9c a9       	ldd	r25, Y+52	; 0x34
  7a:	20 e0       	ldi	r18, 0x00	; 0
  7c:	3f ef       	ldi	r19, 0xFF	; 255
  7e:	4f e7       	ldi	r20, 0x7F	; 127
  80:	57 e4       	ldi	r21, 0x47	; 71
  82:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  86:	18 16       	cp	r1, r24
  88:	04 f4       	brge	.+0      	; 0x8a <LCD_displayCharacter+0x8a>
  8a:	6d a9       	ldd	r22, Y+53	; 0x35
  8c:	7e a9       	ldd	r23, Y+54	; 0x36
  8e:	8f a9       	ldd	r24, Y+55	; 0x37
  90:	98 ad       	ldd	r25, Y+56	; 0x38
  92:	20 e0       	ldi	r18, 0x00	; 0
  94:	30 e0       	ldi	r19, 0x00	; 0
  96:	40 e2       	ldi	r20, 0x20	; 32
  98:	51 e4       	ldi	r21, 0x41	; 65
  9a:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  9e:	dc 01       	movw	r26, r24
  a0:	cb 01       	movw	r24, r22
  a2:	bc 01       	movw	r22, r24
  a4:	cd 01       	movw	r24, r26
  a6:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  aa:	dc 01       	movw	r26, r24
  ac:	cb 01       	movw	r24, r22
  ae:	98 ab       	std	Y+48, r25	; 0x30
  b0:	8f a7       	std	Y+47, r24	; 0x2f
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <LCD_displayCharacter+0xb4>
  b4:	80 e9       	ldi	r24, 0x90	; 144
  b6:	91 e0       	ldi	r25, 0x01	; 1
  b8:	9e a7       	std	Y+46, r25	; 0x2e
  ba:	8d a7       	std	Y+45, r24	; 0x2d
  bc:	8d a5       	ldd	r24, Y+45	; 0x2d
  be:	9e a5       	ldd	r25, Y+46	; 0x2e
  c0:	01 97       	sbiw	r24, 0x01	; 1
  c2:	01 f4       	brne	.+0      	; 0xc4 <LCD_displayCharacter+0xc4>
  c4:	9e a7       	std	Y+46, r25	; 0x2e
  c6:	8d a7       	std	Y+45, r24	; 0x2d
  c8:	8f a5       	ldd	r24, Y+47	; 0x2f
  ca:	98 a9       	ldd	r25, Y+48	; 0x30
  cc:	01 97       	sbiw	r24, 0x01	; 1
  ce:	98 ab       	std	Y+48, r25	; 0x30
  d0:	8f a7       	std	Y+47, r24	; 0x2f
  d2:	8f a5       	ldd	r24, Y+47	; 0x2f
  d4:	98 a9       	ldd	r25, Y+48	; 0x30
  d6:	00 97       	sbiw	r24, 0x00	; 0
  d8:	01 f4       	brne	.+0      	; 0xda <LCD_displayCharacter+0xda>
  da:	00 c0       	rjmp	.+0      	; 0xdc <LCD_displayCharacter+0xdc>
  dc:	69 a9       	ldd	r22, Y+49	; 0x31
  de:	7a a9       	ldd	r23, Y+50	; 0x32
  e0:	8b a9       	ldd	r24, Y+51	; 0x33
  e2:	9c a9       	ldd	r25, Y+52	; 0x34
  e4:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
  e8:	dc 01       	movw	r26, r24
  ea:	cb 01       	movw	r24, r22
  ec:	98 ab       	std	Y+48, r25	; 0x30
  ee:	8f a7       	std	Y+47, r24	; 0x2f
  f0:	8f a5       	ldd	r24, Y+47	; 0x2f
  f2:	98 a9       	ldd	r25, Y+48	; 0x30
  f4:	9c a7       	std	Y+44, r25	; 0x2c
  f6:	8b a7       	std	Y+43, r24	; 0x2b
  f8:	8b a5       	ldd	r24, Y+43	; 0x2b
  fa:	9c a5       	ldd	r25, Y+44	; 0x2c
  fc:	01 97       	sbiw	r24, 0x01	; 1
  fe:	01 f4       	brne	.+0      	; 0x100 <LCD_displayCharacter+0x100>
 100:	9c a7       	std	Y+44, r25	; 0x2c
 102:	8b a7       	std	Y+43, r24	; 0x2b
 104:	82 e0       	ldi	r24, 0x02	; 2
 106:	61 e0       	ldi	r22, 0x01	; 1
 108:	41 e0       	ldi	r20, 0x01	; 1
 10a:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	a0 e8       	ldi	r26, 0x80	; 128
 114:	bf e3       	ldi	r27, 0x3F	; 63
 116:	8f a3       	std	Y+39, r24	; 0x27
 118:	98 a7       	std	Y+40, r25	; 0x28
 11a:	a9 a7       	std	Y+41, r26	; 0x29
 11c:	ba a7       	std	Y+42, r27	; 0x2a
 11e:	6f a1       	ldd	r22, Y+39	; 0x27
 120:	78 a5       	ldd	r23, Y+40	; 0x28
 122:	89 a5       	ldd	r24, Y+41	; 0x29
 124:	9a a5       	ldd	r25, Y+42	; 0x2a
 126:	20 e0       	ldi	r18, 0x00	; 0
 128:	30 e0       	ldi	r19, 0x00	; 0
 12a:	4a e7       	ldi	r20, 0x7A	; 122
 12c:	55 e4       	ldi	r21, 0x45	; 69
 12e:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 132:	dc 01       	movw	r26, r24
 134:	cb 01       	movw	r24, r22
 136:	8b a3       	std	Y+35, r24	; 0x23
 138:	9c a3       	std	Y+36, r25	; 0x24
 13a:	ad a3       	std	Y+37, r26	; 0x25
 13c:	be a3       	std	Y+38, r27	; 0x26
 13e:	6b a1       	ldd	r22, Y+35	; 0x23
 140:	7c a1       	ldd	r23, Y+36	; 0x24
 142:	8d a1       	ldd	r24, Y+37	; 0x25
 144:	9e a1       	ldd	r25, Y+38	; 0x26
 146:	20 e0       	ldi	r18, 0x00	; 0
 148:	30 e0       	ldi	r19, 0x00	; 0
 14a:	40 e8       	ldi	r20, 0x80	; 128
 14c:	5f e3       	ldi	r21, 0x3F	; 63
 14e:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 152:	88 23       	and	r24, r24
 154:	04 f4       	brge	.+0      	; 0x156 <LCD_displayCharacter+0x156>
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	9a a3       	std	Y+34, r25	; 0x22
 15c:	89 a3       	std	Y+33, r24	; 0x21
 15e:	00 c0       	rjmp	.+0      	; 0x160 <LCD_displayCharacter+0x160>
 160:	6b a1       	ldd	r22, Y+35	; 0x23
 162:	7c a1       	ldd	r23, Y+36	; 0x24
 164:	8d a1       	ldd	r24, Y+37	; 0x25
 166:	9e a1       	ldd	r25, Y+38	; 0x26
 168:	20 e0       	ldi	r18, 0x00	; 0
 16a:	3f ef       	ldi	r19, 0xFF	; 255
 16c:	4f e7       	ldi	r20, 0x7F	; 127
 16e:	57 e4       	ldi	r21, 0x47	; 71
 170:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 174:	18 16       	cp	r1, r24
 176:	04 f4       	brge	.+0      	; 0x178 <LCD_displayCharacter+0x178>
 178:	6f a1       	ldd	r22, Y+39	; 0x27
 17a:	78 a5       	ldd	r23, Y+40	; 0x28
 17c:	89 a5       	ldd	r24, Y+41	; 0x29
 17e:	9a a5       	ldd	r25, Y+42	; 0x2a
 180:	20 e0       	ldi	r18, 0x00	; 0
 182:	30 e0       	ldi	r19, 0x00	; 0
 184:	40 e2       	ldi	r20, 0x20	; 32
 186:	51 e4       	ldi	r21, 0x41	; 65
 188:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 18c:	dc 01       	movw	r26, r24
 18e:	cb 01       	movw	r24, r22
 190:	bc 01       	movw	r22, r24
 192:	cd 01       	movw	r24, r26
 194:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 198:	dc 01       	movw	r26, r24
 19a:	cb 01       	movw	r24, r22
 19c:	9a a3       	std	Y+34, r25	; 0x22
 19e:	89 a3       	std	Y+33, r24	; 0x21
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <LCD_displayCharacter+0x1a2>
 1a2:	80 e9       	ldi	r24, 0x90	; 144
 1a4:	91 e0       	ldi	r25, 0x01	; 1
 1a6:	98 a3       	std	Y+32, r25	; 0x20
 1a8:	8f 8f       	std	Y+31, r24	; 0x1f
 1aa:	8f 8d       	ldd	r24, Y+31	; 0x1f
 1ac:	98 a1       	ldd	r25, Y+32	; 0x20
 1ae:	01 97       	sbiw	r24, 0x01	; 1
 1b0:	01 f4       	brne	.+0      	; 0x1b2 <LCD_displayCharacter+0x1b2>
 1b2:	98 a3       	std	Y+32, r25	; 0x20
 1b4:	8f 8f       	std	Y+31, r24	; 0x1f
 1b6:	89 a1       	ldd	r24, Y+33	; 0x21
 1b8:	9a a1       	ldd	r25, Y+34	; 0x22
 1ba:	01 97       	sbiw	r24, 0x01	; 1
 1bc:	9a a3       	std	Y+34, r25	; 0x22
 1be:	89 a3       	std	Y+33, r24	; 0x21
 1c0:	89 a1       	ldd	r24, Y+33	; 0x21
 1c2:	9a a1       	ldd	r25, Y+34	; 0x22
 1c4:	00 97       	sbiw	r24, 0x00	; 0
 1c6:	01 f4       	brne	.+0      	; 0x1c8 <LCD_displayCharacter+0x1c8>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <LCD_displayCharacter+0x1ca>
 1ca:	6b a1       	ldd	r22, Y+35	; 0x23
 1cc:	7c a1       	ldd	r23, Y+36	; 0x24
 1ce:	8d a1       	ldd	r24, Y+37	; 0x25
 1d0:	9e a1       	ldd	r25, Y+38	; 0x26
 1d2:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 1d6:	dc 01       	movw	r26, r24
 1d8:	cb 01       	movw	r24, r22
 1da:	9a a3       	std	Y+34, r25	; 0x22
 1dc:	89 a3       	std	Y+33, r24	; 0x21
 1de:	89 a1       	ldd	r24, Y+33	; 0x21
 1e0:	9a a1       	ldd	r25, Y+34	; 0x22
 1e2:	9e 8f       	std	Y+30, r25	; 0x1e
 1e4:	8d 8f       	std	Y+29, r24	; 0x1d
 1e6:	8d 8d       	ldd	r24, Y+29	; 0x1d
 1e8:	9e 8d       	ldd	r25, Y+30	; 0x1e
 1ea:	01 97       	sbiw	r24, 0x01	; 1
 1ec:	01 f4       	brne	.+0      	; 0x1ee <LCD_displayCharacter+0x1ee>
 1ee:	9e 8f       	std	Y+30, r25	; 0x1e
 1f0:	8d 8f       	std	Y+29, r24	; 0x1d
 1f2:	80 e0       	ldi	r24, 0x00	; 0
 1f4:	69 ad       	ldd	r22, Y+57	; 0x39
 1f6:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 1fa:	80 e0       	ldi	r24, 0x00	; 0
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	a0 e8       	ldi	r26, 0x80	; 128
 200:	bf e3       	ldi	r27, 0x3F	; 63
 202:	89 8f       	std	Y+25, r24	; 0x19
 204:	9a 8f       	std	Y+26, r25	; 0x1a
 206:	ab 8f       	std	Y+27, r26	; 0x1b
 208:	bc 8f       	std	Y+28, r27	; 0x1c
 20a:	69 8d       	ldd	r22, Y+25	; 0x19
 20c:	7a 8d       	ldd	r23, Y+26	; 0x1a
 20e:	8b 8d       	ldd	r24, Y+27	; 0x1b
 210:	9c 8d       	ldd	r25, Y+28	; 0x1c
 212:	20 e0       	ldi	r18, 0x00	; 0
 214:	30 e0       	ldi	r19, 0x00	; 0
 216:	4a e7       	ldi	r20, 0x7A	; 122
 218:	55 e4       	ldi	r21, 0x45	; 69
 21a:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 21e:	dc 01       	movw	r26, r24
 220:	cb 01       	movw	r24, r22
 222:	8d 8b       	std	Y+21, r24	; 0x15
 224:	9e 8b       	std	Y+22, r25	; 0x16
 226:	af 8b       	std	Y+23, r26	; 0x17
 228:	b8 8f       	std	Y+24, r27	; 0x18
 22a:	6d 89       	ldd	r22, Y+21	; 0x15
 22c:	7e 89       	ldd	r23, Y+22	; 0x16
 22e:	8f 89       	ldd	r24, Y+23	; 0x17
 230:	98 8d       	ldd	r25, Y+24	; 0x18
 232:	20 e0       	ldi	r18, 0x00	; 0
 234:	30 e0       	ldi	r19, 0x00	; 0
 236:	40 e8       	ldi	r20, 0x80	; 128
 238:	5f e3       	ldi	r21, 0x3F	; 63
 23a:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 23e:	88 23       	and	r24, r24
 240:	04 f4       	brge	.+0      	; 0x242 <LCD_displayCharacter+0x242>
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	90 e0       	ldi	r25, 0x00	; 0
 246:	9c 8b       	std	Y+20, r25	; 0x14
 248:	8b 8b       	std	Y+19, r24	; 0x13
 24a:	00 c0       	rjmp	.+0      	; 0x24c <LCD_displayCharacter+0x24c>
 24c:	6d 89       	ldd	r22, Y+21	; 0x15
 24e:	7e 89       	ldd	r23, Y+22	; 0x16
 250:	8f 89       	ldd	r24, Y+23	; 0x17
 252:	98 8d       	ldd	r25, Y+24	; 0x18
 254:	20 e0       	ldi	r18, 0x00	; 0
 256:	3f ef       	ldi	r19, 0xFF	; 255
 258:	4f e7       	ldi	r20, 0x7F	; 127
 25a:	57 e4       	ldi	r21, 0x47	; 71
 25c:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 260:	18 16       	cp	r1, r24
 262:	04 f4       	brge	.+0      	; 0x264 <LCD_displayCharacter+0x264>
 264:	69 8d       	ldd	r22, Y+25	; 0x19
 266:	7a 8d       	ldd	r23, Y+26	; 0x1a
 268:	8b 8d       	ldd	r24, Y+27	; 0x1b
 26a:	9c 8d       	ldd	r25, Y+28	; 0x1c
 26c:	20 e0       	ldi	r18, 0x00	; 0
 26e:	30 e0       	ldi	r19, 0x00	; 0
 270:	40 e2       	ldi	r20, 0x20	; 32
 272:	51 e4       	ldi	r21, 0x41	; 65
 274:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 278:	dc 01       	movw	r26, r24
 27a:	cb 01       	movw	r24, r22
 27c:	bc 01       	movw	r22, r24
 27e:	cd 01       	movw	r24, r26
 280:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 284:	dc 01       	movw	r26, r24
 286:	cb 01       	movw	r24, r22
 288:	9c 8b       	std	Y+20, r25	; 0x14
 28a:	8b 8b       	std	Y+19, r24	; 0x13
 28c:	00 c0       	rjmp	.+0      	; 0x28e <LCD_displayCharacter+0x28e>
 28e:	80 e9       	ldi	r24, 0x90	; 144
 290:	91 e0       	ldi	r25, 0x01	; 1
 292:	9a 8b       	std	Y+18, r25	; 0x12
 294:	89 8b       	std	Y+17, r24	; 0x11
 296:	89 89       	ldd	r24, Y+17	; 0x11
 298:	9a 89       	ldd	r25, Y+18	; 0x12
 29a:	01 97       	sbiw	r24, 0x01	; 1
 29c:	01 f4       	brne	.+0      	; 0x29e <LCD_displayCharacter+0x29e>
 29e:	9a 8b       	std	Y+18, r25	; 0x12
 2a0:	89 8b       	std	Y+17, r24	; 0x11
 2a2:	8b 89       	ldd	r24, Y+19	; 0x13
 2a4:	9c 89       	ldd	r25, Y+20	; 0x14
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	9c 8b       	std	Y+20, r25	; 0x14
 2aa:	8b 8b       	std	Y+19, r24	; 0x13
 2ac:	8b 89       	ldd	r24, Y+19	; 0x13
 2ae:	9c 89       	ldd	r25, Y+20	; 0x14
 2b0:	00 97       	sbiw	r24, 0x00	; 0
 2b2:	01 f4       	brne	.+0      	; 0x2b4 <LCD_displayCharacter+0x2b4>
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <LCD_displayCharacter+0x2b6>
 2b6:	6d 89       	ldd	r22, Y+21	; 0x15
 2b8:	7e 89       	ldd	r23, Y+22	; 0x16
 2ba:	8f 89       	ldd	r24, Y+23	; 0x17
 2bc:	98 8d       	ldd	r25, Y+24	; 0x18
 2be:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 2c2:	dc 01       	movw	r26, r24
 2c4:	cb 01       	movw	r24, r22
 2c6:	9c 8b       	std	Y+20, r25	; 0x14
 2c8:	8b 8b       	std	Y+19, r24	; 0x13
 2ca:	8b 89       	ldd	r24, Y+19	; 0x13
 2cc:	9c 89       	ldd	r25, Y+20	; 0x14
 2ce:	98 8b       	std	Y+16, r25	; 0x10
 2d0:	8f 87       	std	Y+15, r24	; 0x0f
 2d2:	8f 85       	ldd	r24, Y+15	; 0x0f
 2d4:	98 89       	ldd	r25, Y+16	; 0x10
 2d6:	01 97       	sbiw	r24, 0x01	; 1
 2d8:	01 f4       	brne	.+0      	; 0x2da <LCD_displayCharacter+0x2da>
 2da:	98 8b       	std	Y+16, r25	; 0x10
 2dc:	8f 87       	std	Y+15, r24	; 0x0f
 2de:	82 e0       	ldi	r24, 0x02	; 2
 2e0:	61 e0       	ldi	r22, 0x01	; 1
 2e2:	40 e0       	ldi	r20, 0x00	; 0
 2e4:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 2e8:	80 e0       	ldi	r24, 0x00	; 0
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	a0 e8       	ldi	r26, 0x80	; 128
 2ee:	bf e3       	ldi	r27, 0x3F	; 63
 2f0:	8b 87       	std	Y+11, r24	; 0x0b
 2f2:	9c 87       	std	Y+12, r25	; 0x0c
 2f4:	ad 87       	std	Y+13, r26	; 0x0d
 2f6:	be 87       	std	Y+14, r27	; 0x0e
 2f8:	6b 85       	ldd	r22, Y+11	; 0x0b
 2fa:	7c 85       	ldd	r23, Y+12	; 0x0c
 2fc:	8d 85       	ldd	r24, Y+13	; 0x0d
 2fe:	9e 85       	ldd	r25, Y+14	; 0x0e
 300:	20 e0       	ldi	r18, 0x00	; 0
 302:	30 e0       	ldi	r19, 0x00	; 0
 304:	4a e7       	ldi	r20, 0x7A	; 122
 306:	55 e4       	ldi	r21, 0x45	; 69
 308:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 30c:	dc 01       	movw	r26, r24
 30e:	cb 01       	movw	r24, r22
 310:	8f 83       	std	Y+7, r24	; 0x07
 312:	98 87       	std	Y+8, r25	; 0x08
 314:	a9 87       	std	Y+9, r26	; 0x09
 316:	ba 87       	std	Y+10, r27	; 0x0a
 318:	6f 81       	ldd	r22, Y+7	; 0x07
 31a:	78 85       	ldd	r23, Y+8	; 0x08
 31c:	89 85       	ldd	r24, Y+9	; 0x09
 31e:	9a 85       	ldd	r25, Y+10	; 0x0a
 320:	20 e0       	ldi	r18, 0x00	; 0
 322:	30 e0       	ldi	r19, 0x00	; 0
 324:	40 e8       	ldi	r20, 0x80	; 128
 326:	5f e3       	ldi	r21, 0x3F	; 63
 328:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 32c:	88 23       	and	r24, r24
 32e:	04 f4       	brge	.+0      	; 0x330 <LCD_displayCharacter+0x330>
 330:	81 e0       	ldi	r24, 0x01	; 1
 332:	90 e0       	ldi	r25, 0x00	; 0
 334:	9e 83       	std	Y+6, r25	; 0x06
 336:	8d 83       	std	Y+5, r24	; 0x05
 338:	00 c0       	rjmp	.+0      	; 0x33a <LCD_displayCharacter+0x33a>
 33a:	6f 81       	ldd	r22, Y+7	; 0x07
 33c:	78 85       	ldd	r23, Y+8	; 0x08
 33e:	89 85       	ldd	r24, Y+9	; 0x09
 340:	9a 85       	ldd	r25, Y+10	; 0x0a
 342:	20 e0       	ldi	r18, 0x00	; 0
 344:	3f ef       	ldi	r19, 0xFF	; 255
 346:	4f e7       	ldi	r20, 0x7F	; 127
 348:	57 e4       	ldi	r21, 0x47	; 71
 34a:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 34e:	18 16       	cp	r1, r24
 350:	04 f4       	brge	.+0      	; 0x352 <LCD_displayCharacter+0x352>
 352:	6b 85       	ldd	r22, Y+11	; 0x0b
 354:	7c 85       	ldd	r23, Y+12	; 0x0c
 356:	8d 85       	ldd	r24, Y+13	; 0x0d
 358:	9e 85       	ldd	r25, Y+14	; 0x0e
 35a:	20 e0       	ldi	r18, 0x00	; 0
 35c:	30 e0       	ldi	r19, 0x00	; 0
 35e:	40 e2       	ldi	r20, 0x20	; 32
 360:	51 e4       	ldi	r21, 0x41	; 65
 362:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 366:	dc 01       	movw	r26, r24
 368:	cb 01       	movw	r24, r22
 36a:	bc 01       	movw	r22, r24
 36c:	cd 01       	movw	r24, r26
 36e:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 372:	dc 01       	movw	r26, r24
 374:	cb 01       	movw	r24, r22
 376:	9e 83       	std	Y+6, r25	; 0x06
 378:	8d 83       	std	Y+5, r24	; 0x05
 37a:	00 c0       	rjmp	.+0      	; 0x37c <LCD_displayCharacter+0x37c>
 37c:	80 e9       	ldi	r24, 0x90	; 144
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	9c 83       	std	Y+4, r25	; 0x04
 382:	8b 83       	std	Y+3, r24	; 0x03
 384:	8b 81       	ldd	r24, Y+3	; 0x03
 386:	9c 81       	ldd	r25, Y+4	; 0x04
 388:	01 97       	sbiw	r24, 0x01	; 1
 38a:	01 f4       	brne	.+0      	; 0x38c <LCD_displayCharacter+0x38c>
 38c:	9c 83       	std	Y+4, r25	; 0x04
 38e:	8b 83       	std	Y+3, r24	; 0x03
 390:	8d 81       	ldd	r24, Y+5	; 0x05
 392:	9e 81       	ldd	r25, Y+6	; 0x06
 394:	01 97       	sbiw	r24, 0x01	; 1
 396:	9e 83       	std	Y+6, r25	; 0x06
 398:	8d 83       	std	Y+5, r24	; 0x05
 39a:	8d 81       	ldd	r24, Y+5	; 0x05
 39c:	9e 81       	ldd	r25, Y+6	; 0x06
 39e:	00 97       	sbiw	r24, 0x00	; 0
 3a0:	01 f4       	brne	.+0      	; 0x3a2 <LCD_displayCharacter+0x3a2>
 3a2:	00 c0       	rjmp	.+0      	; 0x3a4 <LCD_displayCharacter+0x3a4>
 3a4:	6f 81       	ldd	r22, Y+7	; 0x07
 3a6:	78 85       	ldd	r23, Y+8	; 0x08
 3a8:	89 85       	ldd	r24, Y+9	; 0x09
 3aa:	9a 85       	ldd	r25, Y+10	; 0x0a
 3ac:	0e 94 00 00 	call	0	; 0x0 <LCD_displayCharacter>
 3b0:	dc 01       	movw	r26, r24
 3b2:	cb 01       	movw	r24, r22
 3b4:	9e 83       	std	Y+6, r25	; 0x06
 3b6:	8d 83       	std	Y+5, r24	; 0x05
 3b8:	8d 81       	ldd	r24, Y+5	; 0x05
 3ba:	9e 81       	ldd	r25, Y+6	; 0x06
 3bc:	9a 83       	std	Y+2, r25	; 0x02
 3be:	89 83       	std	Y+1, r24	; 0x01
 3c0:	89 81       	ldd	r24, Y+1	; 0x01
 3c2:	9a 81       	ldd	r25, Y+2	; 0x02
 3c4:	01 97       	sbiw	r24, 0x01	; 1
 3c6:	01 f4       	brne	.+0      	; 0x3c8 <LCD_displayCharacter+0x3c8>
 3c8:	9a 83       	std	Y+2, r25	; 0x02
 3ca:	89 83       	std	Y+1, r24	; 0x01
 3cc:	e9 96       	adiw	r28, 0x39	; 57
 3ce:	0f b6       	in	r0, 0x3f	; 63
 3d0:	f8 94       	cli
 3d2:	de bf       	out	0x3e, r29	; 62
 3d4:	0f be       	out	0x3f, r0	; 63
 3d6:	cd bf       	out	0x3d, r28	; 61
 3d8:	cf 91       	pop	r28
 3da:	df 91       	pop	r29
 3dc:	08 95       	ret

Disassembly of section .text.LCD_displayString:

00000000 <LCD_displayString>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LCD_displayString+0x6>
   6:	0f 92       	push	r0
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
}
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	00 c0       	rjmp	.+0      	; 0x14 <LCD_displayString+0x14>
  14:	89 81       	ldd	r24, Y+1	; 0x01
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	fc 01       	movw	r30, r24
  20:	e2 0f       	add	r30, r18
  22:	f3 1f       	adc	r31, r19
  24:	80 81       	ld	r24, Z
  26:	0e 94 00 00 	call	0	; 0x0 <LCD_displayString>
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	8f 5f       	subi	r24, 0xFF	; 255
  2e:	89 83       	std	Y+1, r24	; 0x01
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	28 2f       	mov	r18, r24
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	8a 81       	ldd	r24, Y+2	; 0x02
  38:	9b 81       	ldd	r25, Y+3	; 0x03
  3a:	fc 01       	movw	r30, r24
  3c:	e2 0f       	add	r30, r18
  3e:	f3 1f       	adc	r31, r19
  40:	80 81       	ld	r24, Z
  42:	88 23       	and	r24, r24
  44:	01 f4       	brne	.+0      	; 0x46 <LCD_displayString+0x46>
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	cf 91       	pop	r28
  4e:	df 91       	pop	r29
  50:	08 95       	ret

Disassembly of section .text.LCD_moveCursor:

00000000 <LCD_moveCursor>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LCD_moveCursor+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LCD_moveCursor+0x8>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
}
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	8a 81       	ldd	r24, Y+2	; 0x02
  14:	28 2f       	mov	r18, r24
  16:	30 e0       	ldi	r19, 0x00	; 0
  18:	3d 83       	std	Y+5, r19	; 0x05
  1a:	2c 83       	std	Y+4, r18	; 0x04
  1c:	8c 81       	ldd	r24, Y+4	; 0x04
  1e:	9d 81       	ldd	r25, Y+5	; 0x05
  20:	81 30       	cpi	r24, 0x01	; 1
  22:	91 05       	cpc	r25, r1
  24:	01 f0       	breq	.+0      	; 0x26 <LCD_moveCursor+0x26>
  26:	2c 81       	ldd	r18, Y+4	; 0x04
  28:	3d 81       	ldd	r19, Y+5	; 0x05
  2a:	22 30       	cpi	r18, 0x02	; 2
  2c:	31 05       	cpc	r19, r1
  2e:	04 f4       	brge	.+0      	; 0x30 <LCD_moveCursor+0x30>
  30:	8c 81       	ldd	r24, Y+4	; 0x04
  32:	9d 81       	ldd	r25, Y+5	; 0x05
  34:	00 97       	sbiw	r24, 0x00	; 0
  36:	01 f0       	breq	.+0      	; 0x38 <LCD_moveCursor+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <LCD_moveCursor+0x3a>
  3a:	2c 81       	ldd	r18, Y+4	; 0x04
  3c:	3d 81       	ldd	r19, Y+5	; 0x05
  3e:	22 30       	cpi	r18, 0x02	; 2
  40:	31 05       	cpc	r19, r1
  42:	01 f0       	breq	.+0      	; 0x44 <LCD_moveCursor+0x44>
  44:	8c 81       	ldd	r24, Y+4	; 0x04
  46:	9d 81       	ldd	r25, Y+5	; 0x05
  48:	83 30       	cpi	r24, 0x03	; 3
  4a:	91 05       	cpc	r25, r1
  4c:	01 f0       	breq	.+0      	; 0x4e <LCD_moveCursor+0x4e>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <LCD_moveCursor+0x50>
  50:	8b 81       	ldd	r24, Y+3	; 0x03
  52:	89 83       	std	Y+1, r24	; 0x01
  54:	00 c0       	rjmp	.+0      	; 0x56 <LCD_moveCursor+0x56>
  56:	8b 81       	ldd	r24, Y+3	; 0x03
  58:	80 5c       	subi	r24, 0xC0	; 192
  5a:	89 83       	std	Y+1, r24	; 0x01
  5c:	00 c0       	rjmp	.+0      	; 0x5e <LCD_moveCursor+0x5e>
  5e:	8b 81       	ldd	r24, Y+3	; 0x03
  60:	80 5f       	subi	r24, 0xF0	; 240
  62:	89 83       	std	Y+1, r24	; 0x01
  64:	00 c0       	rjmp	.+0      	; 0x66 <LCD_moveCursor+0x66>
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	80 5b       	subi	r24, 0xB0	; 176
  6a:	89 83       	std	Y+1, r24	; 0x01
  6c:	89 81       	ldd	r24, Y+1	; 0x01
  6e:	80 68       	ori	r24, 0x80	; 128
  70:	0e 94 00 00 	call	0	; 0x0 <LCD_moveCursor>
  74:	0f 90       	pop	r0
  76:	0f 90       	pop	r0
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	cf 91       	pop	r28
  80:	df 91       	pop	r29
  82:	08 95       	ret

Disassembly of section .text.LCD_displayStringRowColumn:

00000000 <LCD_displayStringRowColumn>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LCD_displayStringRowColumn+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LCD_displayStringRowColumn+0x8>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
}
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	5c 83       	std	Y+4, r21	; 0x04
  12:	4b 83       	std	Y+3, r20	; 0x03
  14:	89 81       	ldd	r24, Y+1	; 0x01
  16:	6a 81       	ldd	r22, Y+2	; 0x02
  18:	0e 94 00 00 	call	0	; 0x0 <LCD_displayStringRowColumn>
  1c:	8b 81       	ldd	r24, Y+3	; 0x03
  1e:	9c 81       	ldd	r25, Y+4	; 0x04
  20:	0e 94 00 00 	call	0	; 0x0 <LCD_displayStringRowColumn>
  24:	0f 90       	pop	r0
  26:	0f 90       	pop	r0
  28:	0f 90       	pop	r0
  2a:	0f 90       	pop	r0
  2c:	cf 91       	pop	r28
  2e:	df 91       	pop	r29
  30:	08 95       	ret

Disassembly of section .text.LCD_intgerToString:

00000000 <LCD_intgerToString>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	62 97       	sbiw	r28, 0x12	; 18
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
}
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9a 8b       	std	Y+18, r25	; 0x12
  16:	89 8b       	std	Y+17, r24	; 0x11
  18:	89 89       	ldd	r24, Y+17	; 0x11
  1a:	9a 89       	ldd	r25, Y+18	; 0x12
  1c:	9e 01       	movw	r18, r28
  1e:	2f 5f       	subi	r18, 0xFF	; 255
  20:	3f 4f       	sbci	r19, 0xFF	; 255
  22:	b9 01       	movw	r22, r18
  24:	4a e0       	ldi	r20, 0x0A	; 10
  26:	50 e0       	ldi	r21, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <LCD_intgerToString>
  2c:	ce 01       	movw	r24, r28
  2e:	01 96       	adiw	r24, 0x01	; 1
  30:	0e 94 00 00 	call	0	; 0x0 <LCD_intgerToString>
  34:	62 96       	adiw	r28, 0x12	; 18
  36:	0f b6       	in	r0, 0x3f	; 63
  38:	f8 94       	cli
  3a:	de bf       	out	0x3e, r29	; 62
  3c:	0f be       	out	0x3f, r0	; 63
  3e:	cd bf       	out	0x3d, r28	; 61
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	08 95       	ret

Disassembly of section .text.LCD_clearScreen:

00000000 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	0e 94 00 00 	call	0	; 0x0 <LCD_clearScreen>
}
   e:	cf 91       	pop	r28
  10:	df 91       	pop	r29
  12:	08 95       	ret

ldr_sensor.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000228  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000037d  00000000  00000000  0000025c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.LDR_getLightIntensity 0000009a  00000000  00000000  000005d9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.LDR_getLightIntensity:

00000000 <LDR_getLightIntensity>:
/*
 * Description :
 * Function responsible for calculate the light intensity from the ADC digital value.
 */
uint16 LDR_getLightIntensity(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LDR_getLightIntensity+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LDR_getLightIntensity+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
	uint16 ldr_value = 0;
   c:	1c 82       	std	Y+4, r1	; 0x04
   e:	1b 82       	std	Y+3, r1	; 0x03

	uint16 adc_value = 0;
  10:	1a 82       	std	Y+2, r1	; 0x02
  12:	19 82       	std	Y+1, r1	; 0x01

	ADC_init();			/* Initializing ADC. */
  14:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>

	/* Read ADC channel where the LDR sensor is connected */
	adc_value = ADC_readChannel(LDR_SENSOR_CHANNEL_ID);
  18:	80 e0       	ldi	r24, 0x00	; 0
  1a:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>
  1e:	9a 83       	std	Y+2, r25	; 0x02
  20:	89 83       	std	Y+1, r24	; 0x01

	/* Calculate the light intensity from the ADC value*/
	ldr_value = (uint8)(((uint32)adc_value * LDR_SENSOR_MAX_LIGHT_INTENSITY * ADC_REF_VOLT_VALUE)/(ADC_MAXIMUM_VALUE * LDR_SENSOR_MAX_VOLT_VALUE));
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	9a 81       	ldd	r25, Y+2	; 0x02
  26:	cc 01       	movw	r24, r24
  28:	a0 e0       	ldi	r26, 0x00	; 0
  2a:	b0 e0       	ldi	r27, 0x00	; 0
  2c:	24 e6       	ldi	r18, 0x64	; 100
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	40 e0       	ldi	r20, 0x00	; 0
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	bc 01       	movw	r22, r24
  36:	cd 01       	movw	r24, r26
  38:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>
  3c:	dc 01       	movw	r26, r24
  3e:	cb 01       	movw	r24, r22
  40:	bc 01       	movw	r22, r24
  42:	cd 01       	movw	r24, r26
  44:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>
  48:	dc 01       	movw	r26, r24
  4a:	cb 01       	movw	r24, r22
  4c:	bc 01       	movw	r22, r24
  4e:	cd 01       	movw	r24, r26
  50:	2a e0       	ldi	r18, 0x0A	; 10
  52:	37 ed       	ldi	r19, 0xD7	; 215
  54:	43 e2       	ldi	r20, 0x23	; 35
  56:	50 e4       	ldi	r21, 0x40	; 64
  58:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>
  5c:	dc 01       	movw	r26, r24
  5e:	cb 01       	movw	r24, r22
  60:	bc 01       	movw	r22, r24
  62:	cd 01       	movw	r24, r26
  64:	24 e1       	ldi	r18, 0x14	; 20
  66:	3e ea       	ldi	r19, 0xAE	; 174
  68:	43 e2       	ldi	r20, 0x23	; 35
  6a:	55 e4       	ldi	r21, 0x45	; 69
  6c:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>
  70:	dc 01       	movw	r26, r24
  72:	cb 01       	movw	r24, r22
  74:	bc 01       	movw	r22, r24
  76:	cd 01       	movw	r24, r26
  78:	0e 94 00 00 	call	0	; 0x0 <LDR_getLightIntensity>
  7c:	dc 01       	movw	r26, r24
  7e:	cb 01       	movw	r24, r22
  80:	88 2f       	mov	r24, r24
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	9c 83       	std	Y+4, r25	; 0x04
  86:	8b 83       	std	Y+3, r24	; 0x03

	return ldr_value;
  88:	8b 81       	ldd	r24, Y+3	; 0x03
  8a:	9c 81       	ldd	r25, Y+4	; 0x04
}
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	0f 90       	pop	r0
  94:	cf 91       	pop	r28
  96:	df 91       	pop	r29
  98:	08 95       	ret

lm35_sensor.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000228  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000037f  00000000  00000000  0000025c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.LM35_getTemperature 0000008e  00000000  00000000  000005db  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.LM35_getTemperature:

00000000 <LM35_getTemperature>:
/*
 * Description :
 * Function responsible for calculate the temperature from the ADC digital value.
 */
uint8 LM35_getTemperature(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LM35_getTemperature+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
	uint8 temp_value = 0;
   c:	1b 82       	std	Y+3, r1	; 0x03

	uint16 adc_value = 0;
   e:	1a 82       	std	Y+2, r1	; 0x02
  10:	19 82       	std	Y+1, r1	; 0x01

	ADC_init();			/* Initializing ADC. */
  12:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>

	/* Read ADC channel where the temperature sensor is connected */
	adc_value = ADC_readChannel(SENSOR_CHANNEL_ID);
  16:	81 e0       	ldi	r24, 0x01	; 1
  18:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>
  1c:	9a 83       	std	Y+2, r25	; 0x02
  1e:	89 83       	std	Y+1, r24	; 0x01

	/* Calculate the temperature from the ADC value*/
	temp_value = (uint8)(((uint32)adc_value * SENSOR_MAX_TEMPERATURE * ADC_REF_VOLT_VALUE)/(ADC_MAXIMUM_VALUE * SENSOR_MAX_VOLT_VALUE));
  20:	89 81       	ldd	r24, Y+1	; 0x01
  22:	9a 81       	ldd	r25, Y+2	; 0x02
  24:	cc 01       	movw	r24, r24
  26:	a0 e0       	ldi	r26, 0x00	; 0
  28:	b0 e0       	ldi	r27, 0x00	; 0
  2a:	26 e9       	ldi	r18, 0x96	; 150
  2c:	30 e0       	ldi	r19, 0x00	; 0
  2e:	40 e0       	ldi	r20, 0x00	; 0
  30:	50 e0       	ldi	r21, 0x00	; 0
  32:	bc 01       	movw	r22, r24
  34:	cd 01       	movw	r24, r26
  36:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>
  3a:	dc 01       	movw	r26, r24
  3c:	cb 01       	movw	r24, r22
  3e:	bc 01       	movw	r22, r24
  40:	cd 01       	movw	r24, r26
  42:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>
  46:	dc 01       	movw	r26, r24
  48:	cb 01       	movw	r24, r22
  4a:	bc 01       	movw	r22, r24
  4c:	cd 01       	movw	r24, r26
  4e:	2a e0       	ldi	r18, 0x0A	; 10
  50:	37 ed       	ldi	r19, 0xD7	; 215
  52:	43 e2       	ldi	r20, 0x23	; 35
  54:	50 e4       	ldi	r21, 0x40	; 64
  56:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>
  5a:	dc 01       	movw	r26, r24
  5c:	cb 01       	movw	r24, r22
  5e:	bc 01       	movw	r22, r24
  60:	cd 01       	movw	r24, r26
  62:	20 e0       	ldi	r18, 0x00	; 0
  64:	30 ed       	ldi	r19, 0xD0	; 208
  66:	4f eb       	ldi	r20, 0xBF	; 191
  68:	54 e4       	ldi	r21, 0x44	; 68
  6a:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>
  6e:	dc 01       	movw	r26, r24
  70:	cb 01       	movw	r24, r22
  72:	bc 01       	movw	r22, r24
  74:	cd 01       	movw	r24, r26
  76:	0e 94 00 00 	call	0	; 0x0 <LM35_getTemperature>
  7a:	dc 01       	movw	r26, r24
  7c:	cb 01       	movw	r24, r22
  7e:	8b 83       	std	Y+3, r24	; 0x03

	return temp_value;
  80:	8b 81       	ldd	r24, Y+3	; 0x03
}
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	cf 91       	pop	r28
  8a:	df 91       	pop	r29
  8c:	08 95       	ret

motor.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000002e8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000045b  00000000  00000000  0000031c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.DcMotor_Init 00000040  00000000  00000000  00000777  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.DcMotor_Rotate 0000008a  00000000  00000000  000007b7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.DcMotor_Init:

00000000 <DcMotor_Init>:

/*
 * Function to initialize DC motor.
 */
void DcMotor_Init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Setup pin direction for INT1 & INT2 as output.
	 * Setup pin direction for Enable as output.
	 * */
	GPIO_setupPinDirection(MOTOR_PORT_CONNECTION, PIN_INT1, PIN_OUTPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	66 e0       	ldi	r22, 0x06	; 6
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Init>
	GPIO_setupPinDirection(MOTOR_PORT_CONNECTION, PIN_INT2, PIN_OUTPUT);
  12:	83 e0       	ldi	r24, 0x03	; 3
  14:	67 e0       	ldi	r22, 0x07	; 7
  16:	41 e0       	ldi	r20, 0x01	; 1
  18:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Init>
	GPIO_setupPinDirection(ENABLE_PORT_CONNECTION, ENABLE_PIN, PIN_OUTPUT);
  1c:	81 e0       	ldi	r24, 0x01	; 1
  1e:	63 e0       	ldi	r22, 0x03	; 3
  20:	41 e0       	ldi	r20, 0x01	; 1
  22:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Init>

	/* Stop the motor at the beginning. */
	GPIO_writePin(MOTOR_PORT_CONNECTION, PIN_INT1, LOGIC_LOW);
  26:	83 e0       	ldi	r24, 0x03	; 3
  28:	66 e0       	ldi	r22, 0x06	; 6
  2a:	40 e0       	ldi	r20, 0x00	; 0
  2c:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Init>
	GPIO_writePin(MOTOR_PORT_CONNECTION, PIN_INT2, LOGIC_LOW);
  30:	83 e0       	ldi	r24, 0x03	; 3
  32:	67 e0       	ldi	r22, 0x07	; 7
  34:	40 e0       	ldi	r20, 0x00	; 0
  36:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Init>
}
  3a:	cf 91       	pop	r28
  3c:	df 91       	pop	r29
  3e:	08 95       	ret

Disassembly of section .text.DcMotor_Rotate:

00000000 <DcMotor_Rotate>:

/*
 * Function to initialize DC motor.
 */
void DcMotor_Init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DcMotor_Rotate+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DcMotor_Rotate+0x8>
	/*
	 * Setup pin direction for INT1 & INT2 as output.
	 * Setup pin direction for Enable as output.
	 * */
	GPIO_setupPinDirection(MOTOR_PORT_CONNECTION, PIN_INT1, PIN_OUTPUT);
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	8a 81       	ldd	r24, Y+2	; 0x02
	GPIO_setupPinDirection(MOTOR_PORT_CONNECTION, PIN_INT2, PIN_OUTPUT);
  12:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  1a:	30 e0       	ldi	r19, 0x00	; 0
	GPIO_setupPinDirection(ENABLE_PORT_CONNECTION, ENABLE_PIN, PIN_OUTPUT);
  1c:	3c 83       	std	Y+4, r19	; 0x04
  1e:	2b 83       	std	Y+3, r18	; 0x03
  20:	8b 81       	ldd	r24, Y+3	; 0x03
  22:	9c 81       	ldd	r25, Y+4	; 0x04
  24:	81 30       	cpi	r24, 0x01	; 1

	/* Stop the motor at the beginning. */
	GPIO_writePin(MOTOR_PORT_CONNECTION, PIN_INT1, LOGIC_LOW);
  26:	91 05       	cpc	r25, r1
  28:	01 f0       	breq	.+0      	; 0x2a <DcMotor_Rotate+0x2a>
  2a:	2b 81       	ldd	r18, Y+3	; 0x03
  2c:	3c 81       	ldd	r19, Y+4	; 0x04
  2e:	22 30       	cpi	r18, 0x02	; 2
	GPIO_writePin(MOTOR_PORT_CONNECTION, PIN_INT2, LOGIC_LOW);
  30:	31 05       	cpc	r19, r1
  32:	01 f0       	breq	.+0      	; 0x34 <DcMotor_Rotate+0x34>
  34:	8b 81       	ldd	r24, Y+3	; 0x03
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	00 97       	sbiw	r24, 0x00	; 0
}
  3a:	01 f4       	brne	.+0      	; 0x3c <DcMotor_Rotate+0x3c>
  3c:	83 e0       	ldi	r24, 0x03	; 3
  3e:	66 e0       	ldi	r22, 0x06	; 6
  40:	40 e0       	ldi	r20, 0x00	; 0
  42:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  46:	83 e0       	ldi	r24, 0x03	; 3
  48:	67 e0       	ldi	r22, 0x07	; 7
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  50:	00 c0       	rjmp	.+0      	; 0x52 <DcMotor_Rotate+0x52>
  52:	83 e0       	ldi	r24, 0x03	; 3
  54:	66 e0       	ldi	r22, 0x06	; 6
  56:	41 e0       	ldi	r20, 0x01	; 1
  58:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  5c:	83 e0       	ldi	r24, 0x03	; 3
  5e:	67 e0       	ldi	r22, 0x07	; 7
  60:	40 e0       	ldi	r20, 0x00	; 0
  62:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  66:	00 c0       	rjmp	.+0      	; 0x68 <DcMotor_Rotate+0x68>
  68:	83 e0       	ldi	r24, 0x03	; 3
  6a:	66 e0       	ldi	r22, 0x06	; 6
  6c:	40 e0       	ldi	r20, 0x00	; 0
  6e:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  72:	83 e0       	ldi	r24, 0x03	; 3
  74:	67 e0       	ldi	r22, 0x07	; 7
  76:	41 e0       	ldi	r20, 0x01	; 1
  78:	0e 94 00 00 	call	0	; 0x0 <DcMotor_Rotate>
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	cf 91       	pop	r28
  86:	df 91       	pop	r29
  88:	08 95       	ret

pir_sensor.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000420  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000085b  00000000  00000000  00000454  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.PIR_init 00000018  00000000  00000000  00000caf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.PIR_getState 00000016  00000000  00000000  00000cc7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.PIR_init:

00000000 <PIR_init>:
/*
 *  Function to initialize the PIR driver.
 *  Set up pin direction as input pin.
 */
void PIR_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(PIR_PORT_CONNECTION, PIN_CONNECTION, PIN_INPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	62 e0       	ldi	r22, 0x02	; 2
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <PIR_init>
}
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.PIR_getState:

00000000 <PIR_getState>:
/*
 *  Function to initialize the PIR driver.
 *  Set up pin direction as input pin.
 */
void PIR_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(PIR_PORT_CONNECTION, PIN_CONNECTION, PIN_INPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	62 e0       	ldi	r22, 0x02	; 2
   c:	0e 94 00 00 	call	0	; 0x0 <PIR_getState>
  10:	cf 91       	pop	r28
}
  12:	df 91       	pop	r29
  14:	08 95       	ret

three_leds.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000318  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000046d  00000000  00000000  0000034c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.LEDS_init 0000004a  00000000  00000000  000007b9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.LED_on  00000062  00000000  00000000  00000803  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.LED_off 00000062  00000000  00000000  00000865  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.LEDS_init:

00000000 <LEDS_init>:
 * Make all of them output pins.
 * If the connection is POSITIVE LOGIC, put logic zero at the beginning.
 * Else, put logic one at the beginning (NEGATIVE LOGIC CONNECTION).
 */
void LEDS_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(RED_PORT_CONNECTION, RED_LED, PIN_OUTPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <LEDS_init>
	GPIO_setupPinDirection(GREEN_PORT_CONNECTION, GREEN_LED, PIN_OUTPUT);
  12:	82 e0       	ldi	r24, 0x02	; 2
  14:	61 e0       	ldi	r22, 0x01	; 1
  16:	41 e0       	ldi	r20, 0x01	; 1
  18:	0e 94 00 00 	call	0	; 0x0 <LEDS_init>
	GPIO_setupPinDirection(BLUE_PORT_CONNECTION, BLUE_LED, PIN_OUTPUT);
  1c:	82 e0       	ldi	r24, 0x02	; 2
  1e:	62 e0       	ldi	r22, 0x02	; 2
  20:	41 e0       	ldi	r20, 0x01	; 1
  22:	0e 94 00 00 	call	0	; 0x0 <LEDS_init>

#ifdef CONNECTION_POSITIVE_LOGIC
	GPIO_writePin(RED_PORT_CONNECTION, RED_LED, LOGIC_LOW);
  26:	82 e0       	ldi	r24, 0x02	; 2
  28:	60 e0       	ldi	r22, 0x00	; 0
  2a:	40 e0       	ldi	r20, 0x00	; 0
  2c:	0e 94 00 00 	call	0	; 0x0 <LEDS_init>
	GPIO_writePin(GREEN_PORT_CONNECTION, GREEN_LED, LOGIC_LOW);
  30:	82 e0       	ldi	r24, 0x02	; 2
  32:	61 e0       	ldi	r22, 0x01	; 1
  34:	40 e0       	ldi	r20, 0x00	; 0
  36:	0e 94 00 00 	call	0	; 0x0 <LEDS_init>
	GPIO_writePin(BLUE_PORT_CONNECTION, BLUE_LED, LOGIC_LOW);
  3a:	82 e0       	ldi	r24, 0x02	; 2
  3c:	62 e0       	ldi	r22, 0x02	; 2
  3e:	40 e0       	ldi	r20, 0x00	; 0
  40:	0e 94 00 00 	call	0	; 0x0 <LEDS_init>
#else
	GPIO_writePin(RED_PORT_CONNECTION, RED_LED, LOGIC_HIGH);
	GPIO_writePin(GREEN_PORT_CONNECTION, GREEN_LED, LOGIC_HIGH);
	GPIO_writePin(BLUE_PORT_CONNECTION, BLUE_LED, LOGIC_HIGH);
#endif
}
  44:	cf 91       	pop	r28
  46:	df 91       	pop	r29
  48:	08 95       	ret

Disassembly of section .text.LED_on:

00000000 <LED_on>:
 * Make all of them output pins.
 * If the connection is POSITIVE LOGIC, put logic zero at the beginning.
 * Else, put logic one at the beginning (NEGATIVE LOGIC CONNECTION).
 */
void LEDS_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LED_on+0x6>
   6:	0f 92       	push	r0
	GPIO_setupPinDirection(RED_PORT_CONNECTION, RED_LED, PIN_OUTPUT);
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
	GPIO_setupPinDirection(GREEN_PORT_CONNECTION, GREEN_LED, PIN_OUTPUT);
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
	GPIO_setupPinDirection(BLUE_PORT_CONNECTION, BLUE_LED, PIN_OUTPUT);
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <LED_on+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03

#ifdef CONNECTION_POSITIVE_LOGIC
	GPIO_writePin(RED_PORT_CONNECTION, RED_LED, LOGIC_LOW);
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <LED_on+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
	GPIO_writePin(GREEN_PORT_CONNECTION, GREEN_LED, LOGIC_LOW);
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <LED_on+0x34>
  34:	82 e0       	ldi	r24, 0x02	; 2
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	41 e0       	ldi	r20, 0x01	; 1
	GPIO_writePin(BLUE_PORT_CONNECTION, BLUE_LED, LOGIC_LOW);
  3a:	0e 94 00 00 	call	0	; 0x0 <LED_on>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <LED_on+0x40>
  40:	82 e0       	ldi	r24, 0x02	; 2
  42:	61 e0       	ldi	r22, 0x01	; 1
#else
	GPIO_writePin(RED_PORT_CONNECTION, RED_LED, LOGIC_HIGH);
	GPIO_writePin(GREEN_PORT_CONNECTION, GREEN_LED, LOGIC_HIGH);
	GPIO_writePin(BLUE_PORT_CONNECTION, BLUE_LED, LOGIC_HIGH);
#endif
}
  44:	41 e0       	ldi	r20, 0x01	; 1
  46:	0e 94 00 00 	call	0	; 0x0 <LED_on>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <LED_on+0x4c>
  4c:	82 e0       	ldi	r24, 0x02	; 2
  4e:	62 e0       	ldi	r22, 0x02	; 2
  50:	41 e0       	ldi	r20, 0x01	; 1
  52:	0e 94 00 00 	call	0	; 0x0 <LED_on>
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

Disassembly of section .text.LED_off:

00000000 <LED_off>:
 * Make all of them output pins.
 * If the connection is POSITIVE LOGIC, put logic zero at the beginning.
 * Else, put logic one at the beginning (NEGATIVE LOGIC CONNECTION).
 */
void LEDS_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LED_off+0x6>
   6:	0f 92       	push	r0
	GPIO_setupPinDirection(RED_PORT_CONNECTION, RED_LED, PIN_OUTPUT);
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
	GPIO_setupPinDirection(GREEN_PORT_CONNECTION, GREEN_LED, PIN_OUTPUT);
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
	GPIO_setupPinDirection(BLUE_PORT_CONNECTION, BLUE_LED, PIN_OUTPUT);
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <LED_off+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03

#ifdef CONNECTION_POSITIVE_LOGIC
	GPIO_writePin(RED_PORT_CONNECTION, RED_LED, LOGIC_LOW);
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <LED_off+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
	GPIO_writePin(GREEN_PORT_CONNECTION, GREEN_LED, LOGIC_LOW);
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <LED_off+0x34>
  34:	82 e0       	ldi	r24, 0x02	; 2
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	40 e0       	ldi	r20, 0x00	; 0
	GPIO_writePin(BLUE_PORT_CONNECTION, BLUE_LED, LOGIC_LOW);
  3a:	0e 94 00 00 	call	0	; 0x0 <LED_off>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <LED_off+0x40>
  40:	82 e0       	ldi	r24, 0x02	; 2
  42:	61 e0       	ldi	r22, 0x01	; 1
#else
	GPIO_writePin(RED_PORT_CONNECTION, RED_LED, LOGIC_HIGH);
	GPIO_writePin(GREEN_PORT_CONNECTION, GREEN_LED, LOGIC_HIGH);
	GPIO_writePin(BLUE_PORT_CONNECTION, BLUE_LED, LOGIC_HIGH);
#endif
}
  44:	40 e0       	ldi	r20, 0x00	; 0
  46:	0e 94 00 00 	call	0	; 0x0 <LED_off>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <LED_off+0x4c>
  4c:	82 e0       	ldi	r24, 0x02	; 2
  4e:	62 e0       	ldi	r22, 0x02	; 2
  50:	40 e0       	ldi	r20, 0x00	; 0
  52:	0e 94 00 00 	call	0	; 0x0 <LED_off>
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

ultrasonic_sensor.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000af8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001124  00000000  00000000  00000b2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.g_edgeTime_ICU 00000001  00000000  00000000  00001c50  2**0
                  ALLOC
  6 .bss.g_highTime_ICU 00000002  00000000  00000000  00001c50  2**0
                  ALLOC
  7 .bss.g_edgeTime_EXT_INT 00000001  00000000  00000000  00001c50  2**0
                  ALLOC
  8 .bss.timer_overflow_count 00000001  00000000  00000000  00001c50  2**0
                  ALLOC
  9 .bss.g_highTime_ICU_EXT_INT 00000002  00000000  00000000  00001c50  2**0
                  ALLOC
 10 .text.Ultrasonic_init 0000006e  00000000  00000000  00001c50  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.timer0_setCallBack 00000018  00000000  00000000  00001cbe  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.Ultrasonic_Trigger 00000352  00000000  00000000  00001cd6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.Ultrasonic_readDistance 000000a2  00000000  00000000  00002028  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.Ultrasonic_edgeProcessing 0000004e  00000000  00000000  000020ca  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .rodata.C.12.1488 00000007  00000000  00000000  00002118  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .text.Ultrasonic_edgeProcessing_EXT_INT 000000fe  00000000  00000000  0000211f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.Ultrasonic_init:

00000000 <Ultrasonic_init>:

/*
 * Function to initialize ultrasonic sensor.
 */
void Ultrasonic_init(Ultrasonic_Use use)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Ultrasonic_init+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <Ultrasonic_init+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8d 83       	std	Y+5, r24	; 0x05
	if(use == ICU)
  10:	8d 81       	ldd	r24, Y+5	; 0x05
  12:	88 23       	and	r24, r24
  14:	01 f4       	brne	.+0      	; 0x16 <Ultrasonic_init+0x16>
		/*
		 * Set up ICU Configuration.
		 * Initialize ICU.
		 * Set call back function.
		 */
		ICU_ConfigType ICU_Configurations = {ICU_F_CPU_8, RAISING};
  16:	82 e0       	ldi	r24, 0x02	; 2
  18:	89 83       	std	Y+1, r24	; 0x01
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	8a 83       	std	Y+2, r24	; 0x02
		ICU_setCallBack(Ultrasonic_edgeProcessing);
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_init>
		ICU_init(&ICU_Configurations);
  26:	ce 01       	movw	r24, r28
  28:	01 96       	adiw	r24, 0x01	; 1
  2a:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_init>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <Ultrasonic_init+0x30>
	}
	else
	{
		EXT_INT_ConfigType EXT_INT_Configrations = {INT_2, RISING_EDGE_INT2};
  30:	82 e0       	ldi	r24, 0x02	; 2
  32:	8b 83       	std	Y+3, r24	; 0x03
  34:	81 e0       	ldi	r24, 0x01	; 1
  36:	8c 83       	std	Y+4, r24	; 0x04
		external_interrupt_setCallBack(Ultrasonic_edgeProcessing_EXT_INT, INT_2);
  38:	80 e0       	ldi	r24, 0x00	; 0
  3a:	90 e0       	ldi	r25, 0x00	; 0
  3c:	62 e0       	ldi	r22, 0x02	; 2
  3e:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_init>
		external_interrupt_init(&EXT_INT_Configrations);
  42:	ce 01       	movw	r24, r28
  44:	03 96       	adiw	r24, 0x03	; 3
  46:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_init>
	}
	/* Set up pin direction for trigger pin as output. */
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION1, TRIGGER_PIN1, PIN_OUTPUT);
  4a:	83 e0       	ldi	r24, 0x03	; 3
  4c:	67 e0       	ldi	r22, 0x07	; 7
  4e:	41 e0       	ldi	r20, 0x01	; 1
  50:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_init>
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION2, TRIGGER_PIN2, PIN_OUTPUT);
  54:	81 e0       	ldi	r24, 0x01	; 1
  56:	61 e0       	ldi	r22, 0x01	; 1
  58:	41 e0       	ldi	r20, 0x01	; 1
  5a:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_init>
}
  5e:	0f 90       	pop	r0
  60:	0f 90       	pop	r0
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
  68:	cf 91       	pop	r28
  6a:	df 91       	pop	r29
  6c:	08 95       	ret

Disassembly of section .text.timer0_setCallBack:

00000000 <timer0_setCallBack>:

/*
 * Function to initialize ultrasonic sensor.
 */
void Ultrasonic_init(Ultrasonic_Use use)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	80 91 00 00 	lds	r24, 0x0000
   c:	8f 5f       	subi	r24, 0xFF	; 255
   e:	80 93 00 00 	sts	0x0000, r24
	if(use == ICU)
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
		/*
		 * Set up ICU Configuration.
		 * Initialize ICU.
		 * Set call back function.
		 */
		ICU_ConfigType ICU_Configurations = {ICU_F_CPU_8, RAISING};
  16:	08 95       	ret

Disassembly of section .text.Ultrasonic_Trigger:

00000000 <Ultrasonic_Trigger>:

/*
 * Function to initialize ultrasonic sensor.
 */
void Ultrasonic_init(Ultrasonic_Use use)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e1 97       	sbiw	r28, 0x31	; 49
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
	if(use == ICU)
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 ab       	std	Y+49, r24	; 0x31
		/*
		 * Set up ICU Configuration.
		 * Initialize ICU.
		 * Set call back function.
		 */
		ICU_ConfigType ICU_Configurations = {ICU_F_CPU_8, RAISING};
  16:	89 a9       	ldd	r24, Y+49	; 0x31
  18:	88 23       	and	r24, r24
  1a:	01 f0       	breq	.+0      	; 0x1c <Ultrasonic_Trigger+0x1c>
  1c:	00 c0       	rjmp	.+0      	; 0x1e <Ultrasonic_Trigger+0x1e>
		ICU_setCallBack(Ultrasonic_edgeProcessing);
  1e:	83 e0       	ldi	r24, 0x03	; 3
  20:	67 e0       	ldi	r22, 0x07	; 7
  22:	41 e0       	ldi	r20, 0x01	; 1
  24:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
		ICU_init(&ICU_Configurations);
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	a0 e2       	ldi	r26, 0x20	; 32
  2e:	b1 e4       	ldi	r27, 0x41	; 65
	}
	else
	{
		EXT_INT_ConfigType EXT_INT_Configrations = {INT_2, RISING_EDGE_INT2};
  30:	8d a7       	std	Y+45, r24	; 0x2d
  32:	9e a7       	std	Y+46, r25	; 0x2e
  34:	af a7       	std	Y+47, r26	; 0x2f
  36:	b8 ab       	std	Y+48, r27	; 0x30
		external_interrupt_setCallBack(Ultrasonic_edgeProcessing_EXT_INT, INT_2);
  38:	6d a5       	ldd	r22, Y+45	; 0x2d
  3a:	7e a5       	ldd	r23, Y+46	; 0x2e
  3c:	8f a5       	ldd	r24, Y+47	; 0x2f
  3e:	98 a9       	ldd	r25, Y+48	; 0x30
  40:	2b ea       	ldi	r18, 0xAB	; 171
		external_interrupt_init(&EXT_INT_Configrations);
  42:	3a ea       	ldi	r19, 0xAA	; 170
  44:	4a ea       	ldi	r20, 0xAA	; 170
  46:	50 e4       	ldi	r21, 0x40	; 64
  48:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
	}
	/* Set up pin direction for trigger pin as output. */
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION1, TRIGGER_PIN1, PIN_OUTPUT);
  4c:	dc 01       	movw	r26, r24
  4e:	cb 01       	movw	r24, r22
  50:	89 a7       	std	Y+41, r24	; 0x29
  52:	9a a7       	std	Y+42, r25	; 0x2a
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION2, TRIGGER_PIN2, PIN_OUTPUT);
  54:	ab a7       	std	Y+43, r26	; 0x2b
  56:	bc a7       	std	Y+44, r27	; 0x2c
  58:	69 a5       	ldd	r22, Y+41	; 0x29
  5a:	7a a5       	ldd	r23, Y+42	; 0x2a
  5c:	8b a5       	ldd	r24, Y+43	; 0x2b
}
  5e:	9c a5       	ldd	r25, Y+44	; 0x2c
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	30 e0       	ldi	r19, 0x00	; 0
  64:	40 e8       	ldi	r20, 0x80	; 128
  66:	5f e3       	ldi	r21, 0x3F	; 63
  68:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
  6c:	88 23       	and	r24, r24
  6e:	04 f4       	brge	.+0      	; 0x70 <Ultrasonic_Trigger+0x70>
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	88 a7       	std	Y+40, r24	; 0x28
  74:	00 c0       	rjmp	.+0      	; 0x76 <Ultrasonic_Trigger+0x76>
  76:	69 a5       	ldd	r22, Y+41	; 0x29
  78:	7a a5       	ldd	r23, Y+42	; 0x2a
  7a:	8b a5       	ldd	r24, Y+43	; 0x2b
  7c:	9c a5       	ldd	r25, Y+44	; 0x2c
  7e:	20 e0       	ldi	r18, 0x00	; 0
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	4f e7       	ldi	r20, 0x7F	; 127
  84:	53 e4       	ldi	r21, 0x43	; 67
  86:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
  8a:	18 16       	cp	r1, r24
  8c:	04 f0       	brlt	.+0      	; 0x8e <Ultrasonic_Trigger+0x8e>
  8e:	00 c0       	rjmp	.+0      	; 0x90 <Ultrasonic_Trigger+0x90>
  90:	6d a5       	ldd	r22, Y+45	; 0x2d
  92:	7e a5       	ldd	r23, Y+46	; 0x2e
  94:	8f a5       	ldd	r24, Y+47	; 0x2f
  96:	98 a9       	ldd	r25, Y+48	; 0x30
  98:	20 e0       	ldi	r18, 0x00	; 0
  9a:	30 e0       	ldi	r19, 0x00	; 0
  9c:	4a e7       	ldi	r20, 0x7A	; 122
  9e:	54 e4       	ldi	r21, 0x44	; 68
  a0:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
  a4:	dc 01       	movw	r26, r24
  a6:	cb 01       	movw	r24, r22
  a8:	8c a3       	std	Y+36, r24	; 0x24
  aa:	9d a3       	std	Y+37, r25	; 0x25
  ac:	ae a3       	std	Y+38, r26	; 0x26
  ae:	bf a3       	std	Y+39, r27	; 0x27
  b0:	6c a1       	ldd	r22, Y+36	; 0x24
  b2:	7d a1       	ldd	r23, Y+37	; 0x25
  b4:	8e a1       	ldd	r24, Y+38	; 0x26
  b6:	9f a1       	ldd	r25, Y+39	; 0x27
  b8:	20 e0       	ldi	r18, 0x00	; 0
  ba:	30 e0       	ldi	r19, 0x00	; 0
  bc:	4a e7       	ldi	r20, 0x7A	; 122
  be:	55 e4       	ldi	r21, 0x45	; 69
  c0:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
  c4:	dc 01       	movw	r26, r24
  c6:	cb 01       	movw	r24, r22
  c8:	88 a3       	std	Y+32, r24	; 0x20
  ca:	99 a3       	std	Y+33, r25	; 0x21
  cc:	aa a3       	std	Y+34, r26	; 0x22
  ce:	bb a3       	std	Y+35, r27	; 0x23
  d0:	68 a1       	ldd	r22, Y+32	; 0x20
  d2:	79 a1       	ldd	r23, Y+33	; 0x21
  d4:	8a a1       	ldd	r24, Y+34	; 0x22
  d6:	9b a1       	ldd	r25, Y+35	; 0x23
  d8:	20 e0       	ldi	r18, 0x00	; 0
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	40 e8       	ldi	r20, 0x80	; 128
  de:	5f e3       	ldi	r21, 0x3F	; 63
  e0:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
  e4:	88 23       	and	r24, r24
  e6:	04 f4       	brge	.+0      	; 0xe8 <Ultrasonic_Trigger+0xe8>
  e8:	81 e0       	ldi	r24, 0x01	; 1
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	9f 8f       	std	Y+31, r25	; 0x1f
  ee:	8e 8f       	std	Y+30, r24	; 0x1e
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <Ultrasonic_Trigger+0xf2>
  f2:	68 a1       	ldd	r22, Y+32	; 0x20
  f4:	79 a1       	ldd	r23, Y+33	; 0x21
  f6:	8a a1       	ldd	r24, Y+34	; 0x22
  f8:	9b a1       	ldd	r25, Y+35	; 0x23
  fa:	20 e0       	ldi	r18, 0x00	; 0
  fc:	3f ef       	ldi	r19, 0xFF	; 255
  fe:	4f e7       	ldi	r20, 0x7F	; 127
 100:	57 e4       	ldi	r21, 0x47	; 71
 102:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 106:	18 16       	cp	r1, r24
 108:	04 f4       	brge	.+0      	; 0x10a <Ultrasonic_Trigger+0x10a>
 10a:	6c a1       	ldd	r22, Y+36	; 0x24
 10c:	7d a1       	ldd	r23, Y+37	; 0x25
 10e:	8e a1       	ldd	r24, Y+38	; 0x26
 110:	9f a1       	ldd	r25, Y+39	; 0x27
 112:	20 e0       	ldi	r18, 0x00	; 0
 114:	30 e0       	ldi	r19, 0x00	; 0
 116:	40 e2       	ldi	r20, 0x20	; 32
 118:	51 e4       	ldi	r21, 0x41	; 65
 11a:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 11e:	dc 01       	movw	r26, r24
 120:	cb 01       	movw	r24, r22
 122:	bc 01       	movw	r22, r24
 124:	cd 01       	movw	r24, r26
 126:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 12a:	dc 01       	movw	r26, r24
 12c:	cb 01       	movw	r24, r22
 12e:	9f 8f       	std	Y+31, r25	; 0x1f
 130:	8e 8f       	std	Y+30, r24	; 0x1e
 132:	00 c0       	rjmp	.+0      	; 0x134 <Ultrasonic_Trigger+0x134>
 134:	80 e9       	ldi	r24, 0x90	; 144
 136:	91 e0       	ldi	r25, 0x01	; 1
 138:	9d 8f       	std	Y+29, r25	; 0x1d
 13a:	8c 8f       	std	Y+28, r24	; 0x1c
 13c:	8c 8d       	ldd	r24, Y+28	; 0x1c
 13e:	9d 8d       	ldd	r25, Y+29	; 0x1d
 140:	01 97       	sbiw	r24, 0x01	; 1
 142:	01 f4       	brne	.+0      	; 0x144 <Ultrasonic_Trigger+0x144>
 144:	9d 8f       	std	Y+29, r25	; 0x1d
 146:	8c 8f       	std	Y+28, r24	; 0x1c
 148:	8e 8d       	ldd	r24, Y+30	; 0x1e
 14a:	9f 8d       	ldd	r25, Y+31	; 0x1f
 14c:	01 97       	sbiw	r24, 0x01	; 1
 14e:	9f 8f       	std	Y+31, r25	; 0x1f
 150:	8e 8f       	std	Y+30, r24	; 0x1e
 152:	8e 8d       	ldd	r24, Y+30	; 0x1e
 154:	9f 8d       	ldd	r25, Y+31	; 0x1f
 156:	00 97       	sbiw	r24, 0x00	; 0
 158:	01 f4       	brne	.+0      	; 0x15a <Ultrasonic_Trigger+0x15a>
 15a:	00 c0       	rjmp	.+0      	; 0x15c <Ultrasonic_Trigger+0x15c>
 15c:	68 a1       	ldd	r22, Y+32	; 0x20
 15e:	79 a1       	ldd	r23, Y+33	; 0x21
 160:	8a a1       	ldd	r24, Y+34	; 0x22
 162:	9b a1       	ldd	r25, Y+35	; 0x23
 164:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 168:	dc 01       	movw	r26, r24
 16a:	cb 01       	movw	r24, r22
 16c:	9f 8f       	std	Y+31, r25	; 0x1f
 16e:	8e 8f       	std	Y+30, r24	; 0x1e
 170:	8e 8d       	ldd	r24, Y+30	; 0x1e
 172:	9f 8d       	ldd	r25, Y+31	; 0x1f
 174:	9b 8f       	std	Y+27, r25	; 0x1b
 176:	8a 8f       	std	Y+26, r24	; 0x1a
 178:	8a 8d       	ldd	r24, Y+26	; 0x1a
 17a:	9b 8d       	ldd	r25, Y+27	; 0x1b
 17c:	01 97       	sbiw	r24, 0x01	; 1
 17e:	01 f4       	brne	.+0      	; 0x180 <Ultrasonic_Trigger+0x180>
 180:	9b 8f       	std	Y+27, r25	; 0x1b
 182:	8a 8f       	std	Y+26, r24	; 0x1a
 184:	00 c0       	rjmp	.+0      	; 0x186 <Ultrasonic_Trigger+0x186>
 186:	69 a5       	ldd	r22, Y+41	; 0x29
 188:	7a a5       	ldd	r23, Y+42	; 0x2a
 18a:	8b a5       	ldd	r24, Y+43	; 0x2b
 18c:	9c a5       	ldd	r25, Y+44	; 0x2c
 18e:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 192:	dc 01       	movw	r26, r24
 194:	cb 01       	movw	r24, r22
 196:	88 a7       	std	Y+40, r24	; 0x28
 198:	88 a5       	ldd	r24, Y+40	; 0x28
 19a:	89 8f       	std	Y+25, r24	; 0x19
 19c:	89 8d       	ldd	r24, Y+25	; 0x19
 19e:	8a 95       	dec	r24
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <Ultrasonic_Trigger+0x1a2>
 1a2:	89 8f       	std	Y+25, r24	; 0x19
 1a4:	83 e0       	ldi	r24, 0x03	; 3
 1a6:	67 e0       	ldi	r22, 0x07	; 7
 1a8:	40 e0       	ldi	r20, 0x00	; 0
 1aa:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <Ultrasonic_Trigger+0x1b0>
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	61 e0       	ldi	r22, 0x01	; 1
 1b4:	41 e0       	ldi	r20, 0x01	; 1
 1b6:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	a0 e2       	ldi	r26, 0x20	; 32
 1c0:	b1 e4       	ldi	r27, 0x41	; 65
 1c2:	8d 8b       	std	Y+21, r24	; 0x15
 1c4:	9e 8b       	std	Y+22, r25	; 0x16
 1c6:	af 8b       	std	Y+23, r26	; 0x17
 1c8:	b8 8f       	std	Y+24, r27	; 0x18
 1ca:	6d 89       	ldd	r22, Y+21	; 0x15
 1cc:	7e 89       	ldd	r23, Y+22	; 0x16
 1ce:	8f 89       	ldd	r24, Y+23	; 0x17
 1d0:	98 8d       	ldd	r25, Y+24	; 0x18
 1d2:	2b ea       	ldi	r18, 0xAB	; 171
 1d4:	3a ea       	ldi	r19, 0xAA	; 170
 1d6:	4a ea       	ldi	r20, 0xAA	; 170
 1d8:	50 e4       	ldi	r21, 0x40	; 64
 1da:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 1de:	dc 01       	movw	r26, r24
 1e0:	cb 01       	movw	r24, r22
 1e2:	89 8b       	std	Y+17, r24	; 0x11
 1e4:	9a 8b       	std	Y+18, r25	; 0x12
 1e6:	ab 8b       	std	Y+19, r26	; 0x13
 1e8:	bc 8b       	std	Y+20, r27	; 0x14
 1ea:	69 89       	ldd	r22, Y+17	; 0x11
 1ec:	7a 89       	ldd	r23, Y+18	; 0x12
 1ee:	8b 89       	ldd	r24, Y+19	; 0x13
 1f0:	9c 89       	ldd	r25, Y+20	; 0x14
 1f2:	20 e0       	ldi	r18, 0x00	; 0
 1f4:	30 e0       	ldi	r19, 0x00	; 0
 1f6:	40 e8       	ldi	r20, 0x80	; 128
 1f8:	5f e3       	ldi	r21, 0x3F	; 63
 1fa:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 1fe:	88 23       	and	r24, r24
 200:	04 f4       	brge	.+0      	; 0x202 <Ultrasonic_Trigger+0x202>
 202:	81 e0       	ldi	r24, 0x01	; 1
 204:	88 8b       	std	Y+16, r24	; 0x10
 206:	00 c0       	rjmp	.+0      	; 0x208 <Ultrasonic_Trigger+0x208>
 208:	69 89       	ldd	r22, Y+17	; 0x11
 20a:	7a 89       	ldd	r23, Y+18	; 0x12
 20c:	8b 89       	ldd	r24, Y+19	; 0x13
 20e:	9c 89       	ldd	r25, Y+20	; 0x14
 210:	20 e0       	ldi	r18, 0x00	; 0
 212:	30 e0       	ldi	r19, 0x00	; 0
 214:	4f e7       	ldi	r20, 0x7F	; 127
 216:	53 e4       	ldi	r21, 0x43	; 67
 218:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 21c:	18 16       	cp	r1, r24
 21e:	04 f0       	brlt	.+0      	; 0x220 <Ultrasonic_Trigger+0x220>
 220:	00 c0       	rjmp	.+0      	; 0x222 <Ultrasonic_Trigger+0x222>
 222:	6d 89       	ldd	r22, Y+21	; 0x15
 224:	7e 89       	ldd	r23, Y+22	; 0x16
 226:	8f 89       	ldd	r24, Y+23	; 0x17
 228:	98 8d       	ldd	r25, Y+24	; 0x18
 22a:	20 e0       	ldi	r18, 0x00	; 0
 22c:	30 e0       	ldi	r19, 0x00	; 0
 22e:	4a e7       	ldi	r20, 0x7A	; 122
 230:	54 e4       	ldi	r21, 0x44	; 68
 232:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 236:	dc 01       	movw	r26, r24
 238:	cb 01       	movw	r24, r22
 23a:	8c 87       	std	Y+12, r24	; 0x0c
 23c:	9d 87       	std	Y+13, r25	; 0x0d
 23e:	ae 87       	std	Y+14, r26	; 0x0e
 240:	bf 87       	std	Y+15, r27	; 0x0f
 242:	6c 85       	ldd	r22, Y+12	; 0x0c
 244:	7d 85       	ldd	r23, Y+13	; 0x0d
 246:	8e 85       	ldd	r24, Y+14	; 0x0e
 248:	9f 85       	ldd	r25, Y+15	; 0x0f
 24a:	20 e0       	ldi	r18, 0x00	; 0
 24c:	30 e0       	ldi	r19, 0x00	; 0
 24e:	4a e7       	ldi	r20, 0x7A	; 122
 250:	55 e4       	ldi	r21, 0x45	; 69
 252:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 256:	dc 01       	movw	r26, r24
 258:	cb 01       	movw	r24, r22
 25a:	88 87       	std	Y+8, r24	; 0x08
 25c:	99 87       	std	Y+9, r25	; 0x09
 25e:	aa 87       	std	Y+10, r26	; 0x0a
 260:	bb 87       	std	Y+11, r27	; 0x0b
 262:	68 85       	ldd	r22, Y+8	; 0x08
 264:	79 85       	ldd	r23, Y+9	; 0x09
 266:	8a 85       	ldd	r24, Y+10	; 0x0a
 268:	9b 85       	ldd	r25, Y+11	; 0x0b
 26a:	20 e0       	ldi	r18, 0x00	; 0
 26c:	30 e0       	ldi	r19, 0x00	; 0
 26e:	40 e8       	ldi	r20, 0x80	; 128
 270:	5f e3       	ldi	r21, 0x3F	; 63
 272:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 276:	88 23       	and	r24, r24
 278:	04 f4       	brge	.+0      	; 0x27a <Ultrasonic_Trigger+0x27a>
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	9f 83       	std	Y+7, r25	; 0x07
 280:	8e 83       	std	Y+6, r24	; 0x06
 282:	00 c0       	rjmp	.+0      	; 0x284 <Ultrasonic_Trigger+0x284>
 284:	68 85       	ldd	r22, Y+8	; 0x08
 286:	79 85       	ldd	r23, Y+9	; 0x09
 288:	8a 85       	ldd	r24, Y+10	; 0x0a
 28a:	9b 85       	ldd	r25, Y+11	; 0x0b
 28c:	20 e0       	ldi	r18, 0x00	; 0
 28e:	3f ef       	ldi	r19, 0xFF	; 255
 290:	4f e7       	ldi	r20, 0x7F	; 127
 292:	57 e4       	ldi	r21, 0x47	; 71
 294:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 298:	18 16       	cp	r1, r24
 29a:	04 f4       	brge	.+0      	; 0x29c <Ultrasonic_Trigger+0x29c>
 29c:	6c 85       	ldd	r22, Y+12	; 0x0c
 29e:	7d 85       	ldd	r23, Y+13	; 0x0d
 2a0:	8e 85       	ldd	r24, Y+14	; 0x0e
 2a2:	9f 85       	ldd	r25, Y+15	; 0x0f
 2a4:	20 e0       	ldi	r18, 0x00	; 0
 2a6:	30 e0       	ldi	r19, 0x00	; 0
 2a8:	40 e2       	ldi	r20, 0x20	; 32
 2aa:	51 e4       	ldi	r21, 0x41	; 65
 2ac:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 2b0:	dc 01       	movw	r26, r24
 2b2:	cb 01       	movw	r24, r22
 2b4:	bc 01       	movw	r22, r24
 2b6:	cd 01       	movw	r24, r26
 2b8:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 2bc:	dc 01       	movw	r26, r24
 2be:	cb 01       	movw	r24, r22
 2c0:	9f 83       	std	Y+7, r25	; 0x07
 2c2:	8e 83       	std	Y+6, r24	; 0x06
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <Ultrasonic_Trigger+0x2c6>
 2c6:	80 e9       	ldi	r24, 0x90	; 144
 2c8:	91 e0       	ldi	r25, 0x01	; 1
 2ca:	9d 83       	std	Y+5, r25	; 0x05
 2cc:	8c 83       	std	Y+4, r24	; 0x04
 2ce:	8c 81       	ldd	r24, Y+4	; 0x04
 2d0:	9d 81       	ldd	r25, Y+5	; 0x05
 2d2:	01 97       	sbiw	r24, 0x01	; 1
 2d4:	01 f4       	brne	.+0      	; 0x2d6 <Ultrasonic_Trigger+0x2d6>
 2d6:	9d 83       	std	Y+5, r25	; 0x05
 2d8:	8c 83       	std	Y+4, r24	; 0x04
 2da:	8e 81       	ldd	r24, Y+6	; 0x06
 2dc:	9f 81       	ldd	r25, Y+7	; 0x07
 2de:	01 97       	sbiw	r24, 0x01	; 1
 2e0:	9f 83       	std	Y+7, r25	; 0x07
 2e2:	8e 83       	std	Y+6, r24	; 0x06
 2e4:	8e 81       	ldd	r24, Y+6	; 0x06
 2e6:	9f 81       	ldd	r25, Y+7	; 0x07
 2e8:	00 97       	sbiw	r24, 0x00	; 0
 2ea:	01 f4       	brne	.+0      	; 0x2ec <Ultrasonic_Trigger+0x2ec>
 2ec:	00 c0       	rjmp	.+0      	; 0x2ee <Ultrasonic_Trigger+0x2ee>
 2ee:	68 85       	ldd	r22, Y+8	; 0x08
 2f0:	79 85       	ldd	r23, Y+9	; 0x09
 2f2:	8a 85       	ldd	r24, Y+10	; 0x0a
 2f4:	9b 85       	ldd	r25, Y+11	; 0x0b
 2f6:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 2fa:	dc 01       	movw	r26, r24
 2fc:	cb 01       	movw	r24, r22
 2fe:	9f 83       	std	Y+7, r25	; 0x07
 300:	8e 83       	std	Y+6, r24	; 0x06
 302:	8e 81       	ldd	r24, Y+6	; 0x06
 304:	9f 81       	ldd	r25, Y+7	; 0x07
 306:	9b 83       	std	Y+3, r25	; 0x03
 308:	8a 83       	std	Y+2, r24	; 0x02
 30a:	8a 81       	ldd	r24, Y+2	; 0x02
 30c:	9b 81       	ldd	r25, Y+3	; 0x03
 30e:	01 97       	sbiw	r24, 0x01	; 1
 310:	01 f4       	brne	.+0      	; 0x312 <Ultrasonic_Trigger+0x312>
 312:	9b 83       	std	Y+3, r25	; 0x03
 314:	8a 83       	std	Y+2, r24	; 0x02
 316:	00 c0       	rjmp	.+0      	; 0x318 <Ultrasonic_Trigger+0x318>
 318:	69 89       	ldd	r22, Y+17	; 0x11
 31a:	7a 89       	ldd	r23, Y+18	; 0x12
 31c:	8b 89       	ldd	r24, Y+19	; 0x13
 31e:	9c 89       	ldd	r25, Y+20	; 0x14
 320:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 324:	dc 01       	movw	r26, r24
 326:	cb 01       	movw	r24, r22
 328:	88 8b       	std	Y+16, r24	; 0x10
 32a:	88 89       	ldd	r24, Y+16	; 0x10
 32c:	89 83       	std	Y+1, r24	; 0x01
 32e:	89 81       	ldd	r24, Y+1	; 0x01
 330:	8a 95       	dec	r24
 332:	01 f4       	brne	.+0      	; 0x334 <Ultrasonic_Trigger+0x334>
 334:	89 83       	std	Y+1, r24	; 0x01
 336:	81 e0       	ldi	r24, 0x01	; 1
 338:	61 e0       	ldi	r22, 0x01	; 1
 33a:	40 e0       	ldi	r20, 0x00	; 0
 33c:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_Trigger>
 340:	e1 96       	adiw	r28, 0x31	; 49
 342:	0f b6       	in	r0, 0x3f	; 63
 344:	f8 94       	cli
 346:	de bf       	out	0x3e, r29	; 62
 348:	0f be       	out	0x3f, r0	; 63
 34a:	cd bf       	out	0x3d, r28	; 61
 34c:	cf 91       	pop	r28
 34e:	df 91       	pop	r29
 350:	08 95       	ret

Disassembly of section .text.Ultrasonic_readDistance:

00000000 <Ultrasonic_readDistance>:

/*
 * Function to initialize ultrasonic sensor.
 */
void Ultrasonic_init(Ultrasonic_Use use)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Ultrasonic_readDistance+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
	if(use == ICU)
  10:	88 23       	and	r24, r24
  12:	01 f4       	brne	.+0      	; 0x14 <Ultrasonic_readDistance+0x14>
  14:	80 e0       	ldi	r24, 0x00	; 0
		/*
		 * Set up ICU Configuration.
		 * Initialize ICU.
		 * Set call back function.
		 */
		ICU_ConfigType ICU_Configurations = {ICU_F_CPU_8, RAISING};
  16:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
  1a:	80 91 00 00 	lds	r24, 0x0000
		ICU_setCallBack(Ultrasonic_edgeProcessing);
  1e:	90 91 00 00 	lds	r25, 0x0000
  22:	cc 01       	movw	r24, r24
  24:	a0 e0       	ldi	r26, 0x00	; 0
		ICU_init(&ICU_Configurations);
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	bc 01       	movw	r22, r24
  2a:	cd 01       	movw	r24, r26
  2c:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
	}
	else
	{
		EXT_INT_ConfigType EXT_INT_Configrations = {INT_2, RISING_EDGE_INT2};
  30:	dc 01       	movw	r26, r24
  32:	cb 01       	movw	r24, r22
  34:	bc 01       	movw	r22, r24
  36:	cd 01       	movw	r24, r26
		external_interrupt_setCallBack(Ultrasonic_edgeProcessing_EXT_INT, INT_2);
  38:	23 e3       	ldi	r18, 0x33	; 51
  3a:	33 e3       	ldi	r19, 0x33	; 51
  3c:	4b ee       	ldi	r20, 0xEB	; 235
  3e:	52 e4       	ldi	r21, 0x42	; 66
  40:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
		external_interrupt_init(&EXT_INT_Configrations);
  44:	dc 01       	movw	r26, r24
  46:	cb 01       	movw	r24, r22
  48:	bc 01       	movw	r22, r24
	}
	/* Set up pin direction for trigger pin as output. */
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION1, TRIGGER_PIN1, PIN_OUTPUT);
  4a:	cd 01       	movw	r24, r26
  4c:	20 e0       	ldi	r18, 0x00	; 0
  4e:	30 e0       	ldi	r19, 0x00	; 0
  50:	40 e8       	ldi	r20, 0x80	; 128
  52:	5f e3       	ldi	r21, 0x3F	; 63
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION2, TRIGGER_PIN2, PIN_OUTPUT);
  54:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
  58:	dc 01       	movw	r26, r24
  5a:	cb 01       	movw	r24, r22
  5c:	bc 01       	movw	r22, r24
}
  5e:	cd 01       	movw	r24, r26
  60:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
  64:	dc 01       	movw	r26, r24
  66:	cb 01       	movw	r24, r22
  68:	9b 83       	std	Y+3, r25	; 0x03
  6a:	8a 83       	std	Y+2, r24	; 0x02
  6c:	00 c0       	rjmp	.+0      	; 0x6e <Ultrasonic_readDistance+0x6e>
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
  74:	80 91 00 00 	lds	r24, 0x0000
  78:	90 91 00 00 	lds	r25, 0x0000
  7c:	25 e7       	ldi	r18, 0x75	; 117
  7e:	30 e0       	ldi	r19, 0x00	; 0
  80:	b9 01       	movw	r22, r18
  82:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_readDistance>
  86:	cb 01       	movw	r24, r22
  88:	9c 01       	movw	r18, r24
  8a:	2f 5f       	subi	r18, 0xFF	; 255
  8c:	3f 4f       	sbci	r19, 0xFF	; 255
  8e:	3b 83       	std	Y+3, r19	; 0x03
  90:	2a 83       	std	Y+2, r18	; 0x02
  92:	8a 81       	ldd	r24, Y+2	; 0x02
  94:	9b 81       	ldd	r25, Y+3	; 0x03
  96:	0f 90       	pop	r0
  98:	0f 90       	pop	r0
  9a:	0f 90       	pop	r0
  9c:	cf 91       	pop	r28
  9e:	df 91       	pop	r29
  a0:	08 95       	ret

Disassembly of section .text.Ultrasonic_edgeProcessing:

00000000 <Ultrasonic_edgeProcessing>:

/*
 * Function to initialize ultrasonic sensor.
 */
void Ultrasonic_init(Ultrasonic_Use use)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	80 91 00 00 	lds	r24, 0x0000
   c:	8f 5f       	subi	r24, 0xFF	; 255
   e:	80 93 00 00 	sts	0x0000, r24
	if(use == ICU)
  12:	80 91 00 00 	lds	r24, 0x0000
		/*
		 * Set up ICU Configuration.
		 * Initialize ICU.
		 * Set call back function.
		 */
		ICU_ConfigType ICU_Configurations = {ICU_F_CPU_8, RAISING};
  16:	81 30       	cpi	r24, 0x01	; 1
  18:	01 f4       	brne	.+0      	; 0x1a <Ultrasonic_edgeProcessing+0x1a>
  1a:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing>
		ICU_setCallBack(Ultrasonic_edgeProcessing);
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing>
  24:	00 c0       	rjmp	.+0      	; 0x26 <Ultrasonic_edgeProcessing+0x26>
		ICU_init(&ICU_Configurations);
  26:	80 91 00 00 	lds	r24, 0x0000
  2a:	82 30       	cpi	r24, 0x02	; 2
  2c:	01 f4       	brne	.+0      	; 0x2e <Ultrasonic_edgeProcessing+0x2e>
  2e:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing>
	}
	else
	{
		EXT_INT_ConfigType EXT_INT_Configrations = {INT_2, RISING_EDGE_INT2};
  32:	90 93 00 00 	sts	0x0000, r25
  36:	80 93 00 00 	sts	0x0000, r24
		external_interrupt_setCallBack(Ultrasonic_edgeProcessing_EXT_INT, INT_2);
  3a:	81 e0       	ldi	r24, 0x01	; 1
  3c:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing>
  40:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing>
		external_interrupt_init(&EXT_INT_Configrations);
  44:	10 92 00 00 	sts	0x0000, r1
  48:	cf 91       	pop	r28
	}
	/* Set up pin direction for trigger pin as output. */
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION1, TRIGGER_PIN1, PIN_OUTPUT);
  4a:	df 91       	pop	r29
  4c:	08 95       	ret

Disassembly of section .text.Ultrasonic_edgeProcessing_EXT_INT:

00000000 <Ultrasonic_edgeProcessing_EXT_INT>:

/*
 * Function to initialize ultrasonic sensor.
 */
void Ultrasonic_init(Ultrasonic_Use use)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	60 97       	sbiw	r28, 0x10	; 16
   e:	0f b6       	in	r0, 0x3f	; 63
	if(use == ICU)
  10:	f8 94       	cli
  12:	de bf       	out	0x3e, r29	; 62
  14:	0f be       	out	0x3f, r0	; 63
		/*
		 * Set up ICU Configuration.
		 * Initialize ICU.
		 * Set call back function.
		 */
		ICU_ConfigType ICU_Configurations = {ICU_F_CPU_8, RAISING};
  16:	cd bf       	out	0x3d, r28	; 61
  18:	80 91 00 00 	lds	r24, 0x0000
  1c:	8f 5f       	subi	r24, 0xFF	; 255
		ICU_setCallBack(Ultrasonic_edgeProcessing);
  1e:	80 93 00 00 	sts	0x0000, r24
  22:	80 91 00 00 	lds	r24, 0x0000
		ICU_init(&ICU_Configurations);
  26:	81 30       	cpi	r24, 0x01	; 1
  28:	01 f4       	brne	.+0      	; 0x2a <Ultrasonic_edgeProcessing_EXT_INT+0x2a>
  2a:	80 e0       	ldi	r24, 0x00	; 0
  2c:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
	}
	else
	{
		EXT_INT_ConfigType EXT_INT_Configrations = {INT_2, RISING_EDGE_INT2};
  30:	82 e0       	ldi	r24, 0x02	; 2
  32:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  36:	82 e0       	ldi	r24, 0x02	; 2
		external_interrupt_setCallBack(Ultrasonic_edgeProcessing_EXT_INT, INT_2);
  38:	89 83       	std	Y+1, r24	; 0x01
  3a:	1a 82       	std	Y+2, r1	; 0x02
  3c:	ce 01       	movw	r24, r28
  3e:	01 96       	adiw	r24, 0x01	; 1
  40:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
		external_interrupt_init(&EXT_INT_Configrations);
  44:	ce 01       	movw	r24, r28
  46:	03 96       	adiw	r24, 0x03	; 3
  48:	9d 87       	std	Y+13, r25	; 0x0d
	}
	/* Set up pin direction for trigger pin as output. */
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION1, TRIGGER_PIN1, PIN_OUTPUT);
  4a:	8c 87       	std	Y+12, r24	; 0x0c
  4c:	e0 e0       	ldi	r30, 0x00	; 0
  4e:	f0 e0       	ldi	r31, 0x00	; 0
  50:	ff 87       	std	Y+15, r31	; 0x0f
  52:	ee 87       	std	Y+14, r30	; 0x0e
	GPIO_setupPinDirection(TRIGGER_PORT_CONNECTION2, TRIGGER_PIN2, PIN_OUTPUT);
  54:	f7 e0       	ldi	r31, 0x07	; 7
  56:	f8 8b       	std	Y+16, r31	; 0x10
  58:	ee 85       	ldd	r30, Y+14	; 0x0e
  5a:	ff 85       	ldd	r31, Y+15	; 0x0f
  5c:	00 80       	ld	r0, Z
}
  5e:	8e 85       	ldd	r24, Y+14	; 0x0e
  60:	9f 85       	ldd	r25, Y+15	; 0x0f
  62:	01 96       	adiw	r24, 0x01	; 1
  64:	9f 87       	std	Y+15, r25	; 0x0f
  66:	8e 87       	std	Y+14, r24	; 0x0e
  68:	ec 85       	ldd	r30, Y+12	; 0x0c
  6a:	fd 85       	ldd	r31, Y+13	; 0x0d
  6c:	00 82       	st	Z, r0
  6e:	8c 85       	ldd	r24, Y+12	; 0x0c
  70:	9d 85       	ldd	r25, Y+13	; 0x0d
  72:	01 96       	adiw	r24, 0x01	; 1
  74:	9d 87       	std	Y+13, r25	; 0x0d
  76:	8c 87       	std	Y+12, r24	; 0x0c
  78:	98 89       	ldd	r25, Y+16	; 0x10
  7a:	91 50       	subi	r25, 0x01	; 1
  7c:	98 8b       	std	Y+16, r25	; 0x10
  7e:	e8 89       	ldd	r30, Y+16	; 0x10
  80:	ee 23       	and	r30, r30
  82:	01 f4       	brne	.+0      	; 0x84 <Ultrasonic_edgeProcessing_EXT_INT+0x84>
  84:	80 e0       	ldi	r24, 0x00	; 0
  86:	90 e0       	ldi	r25, 0x00	; 0
  88:	60 e0       	ldi	r22, 0x00	; 0
  8a:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  8e:	10 92 00 00 	sts	0x0000, r1
  92:	ce 01       	movw	r24, r28
  94:	03 96       	adiw	r24, 0x03	; 3
  96:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  9a:	00 c0       	rjmp	.+0      	; 0x9c <Ultrasonic_edgeProcessing_EXT_INT+0x9c>
  9c:	80 91 00 00 	lds	r24, 0x0000
  a0:	82 30       	cpi	r24, 0x02	; 2
  a2:	01 f4       	brne	.+0      	; 0xa4 <Ultrasonic_edgeProcessing_EXT_INT+0xa4>
  a4:	80 91 00 00 	lds	r24, 0x0000
  a8:	88 2f       	mov	r24, r24
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	98 2f       	mov	r25, r24
  ae:	88 27       	eor	r24, r24
  b0:	8c 01       	movw	r16, r24
  b2:	80 e0       	ldi	r24, 0x00	; 0
  b4:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  b8:	80 0f       	add	r24, r16
  ba:	91 1f       	adc	r25, r17
  bc:	90 93 00 00 	sts	0x0000, r25
  c0:	80 93 00 00 	sts	0x0000, r24
  c4:	80 e0       	ldi	r24, 0x00	; 0
  c6:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  ca:	10 92 00 00 	sts	0x0000, r1
  ce:	82 e0       	ldi	r24, 0x02	; 2
  d0:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  d4:	82 e0       	ldi	r24, 0x02	; 2
  d6:	8a 87       	std	Y+10, r24	; 0x0a
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	8b 87       	std	Y+11, r24	; 0x0b
  dc:	ce 01       	movw	r24, r28
  de:	0a 96       	adiw	r24, 0x0a	; 10
  e0:	0e 94 00 00 	call	0	; 0x0 <Ultrasonic_edgeProcessing_EXT_INT>
  e4:	10 92 00 00 	sts	0x0000, r1
  e8:	60 96       	adiw	r28, 0x10	; 16
  ea:	0f b6       	in	r0, 0x3f	; 63
  ec:	f8 94       	cli
  ee:	de bf       	out	0x3e, r29	; 62
  f0:	0f be       	out	0x3f, r0	; 63
  f2:	cd bf       	out	0x3d, r28	; 61
  f4:	cf 91       	pop	r28
  f6:	df 91       	pop	r29
  f8:	1f 91       	pop	r17
  fa:	0f 91       	pop	r16
  fc:	08 95       	ret
